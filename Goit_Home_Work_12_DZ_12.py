# ============================= Модуль 12 (останій в Python Core) =======================================

# +++++++++++++++++++++++++++++++++  Серіалізація об'єктів Python ++++++++++++++++++++++

#                             1.Серіалізація об'єктів Python
#                             2.Серіалізація об'єктів Python за допомогою pickle
#                             3.Серіалізація об'єктів Python за допомогою json
#                             4.Робота з таблицями CSV у Python
#                             5.Управління порядком серіалізації
#                             6.Створення копій об'єктів Python



# ================================ Звдання 1 / Task 1 ======================================

# ================================  2.Серіалізація об'єктів Python за допомогою pickle  ==========================

# Для серіалізації/десеріалізації об'єктів Python, коли важлива швидкість, коректність і невеликий розмір пам'яті, 
# що використовується, найкраще підійде пакет pickle.

# У пакета pickle є дві пари парних методів:

# Перша пара методів - це dumps, який упаковує в byte-рядок об'єкт, і loads - він розпаковує з byte-рядки в об'єкт.

# Ці методи потрібні, коли ми хочемо контролювати, що робити з byte поданням, наприклад, 
# відправити його по мережі або прийняти з мережі.

# import pickle

# some_data = {
#     (1, 3.5): 'tuple',
#     2: [1, 2, 3],
#     'a': {'key': 'value'}
# }

# byte_string = pickle.dumps(some_data)
# unpacked = pickle.loads(byte_string)

# print(unpacked == some_data)  # True
# print(unpacked is some_data)  # False
# У цьому прикладі упакований у byte_string словник some_data розпакован в unpacked та unpacked суворо дорівнює some_data, 
# але це все ж таки не той самий об'єкт.

# Друга пара методів: dump та load - вони упаковують у відкритий для byte-запису 
# файл і розпаковують з відкритого для byte-читання файлу.

# import pickle

# some_data = {
#     (1, 3.5): 'tuple',
#     2: [1, 2, 3],
#     'a': {'key': 'value'}
# }

# file_name = 'data.bin'

# with open(file_name, "wb") as fh:
#     pickle.dump(some_data, fh)

# with open(file_name, "rb") as fh:
#     unpacked = pickle.load(fh)

# print(unpacked == some_data)  # True
# print(unpacked is some_data)  # False
# Результат аналогічний попередньому прикладу. Головна відмінність у тому, 
# що під час виконання цього коду в робочій папці з'явився файл data.bin

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

#     {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів 
# за допомогою пакета pickle та зберігання отриманих даних у бінарному файлі.

# Перша функція write_contacts_to_file приймає два параметри: filename - ім'я файлу, contacts - список контактів. 
# Вона зберігає вказаний список у файл, використовуючи метод dump пакету pickle.

# Друга функція read_contacts_from_file читає та повертає зазначений список contacts з файлу filename, 
# використовуючи метод load пакету pickle.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Серіалізація і обернена до неї процедура Десіралізація схожа на роботу кодера - декодекр.
#            Спочатку - серіалізуємо дані , потім їх десерелізуємо за потреби. (По замовчуванню переводить в 
#             байт-рядки тому якщо треба працювати з серіалізованими даними то потрібно застосуовуати методи байт-рядків)(*для себе)


# import pickle # Імпортуємо пакет *pickle- Пакет Для серіалізації/десеріалізації об'єктів Python, 
#               # коли важлива швидкість, коректність і невеликий розмір пам'яті. 
#               # Просто перетворює всі дані в байт рядки і повертає за потреби з байт рядків дані назад . 
#               # також має методи запису і читання з файлу цих байт рядків.


# def write_contacts_to_file(filename, contacts):
#     ''' Функція приймає два аргумента , *filename - імя файлу в який будемо записувати наші контакти у вигляді байт-ряків
#     і contacts - самі дані які треба записати .
#     Відкриває наш файл для запису байт-рядків і за допомогою  метод *pickle.dump(contacts, fh) 
#     записуємо туди свої контакти у вигляді байт рядків'''
    
#     with open(filename, "wb") as fh: # Відкрити файл з іменем *filename(шлях до файлу тип Path) 
#                                      # для запису з параметром "wb" -байт-рядків, Задопомогою менеджера контексту *with ... as
#         pickle.dump(contacts, fh)    # Перетворюємо наші контакти в байт-рядки і передаємо їх файл-хендлеру *fh 
#                                      # за допомгою методу *pickle.dump(contacts, fh).
#                                      # По завершеню файл автоматично закриється і дані вньому збережуться.Читай менеджер контексту.
    

# def read_contacts_from_file(filename):
#     ''' Функція приймає один аргумента , *filename - імя файлу з якого будемо зчитувати наші контакти у вигляді байт-ряків
#     і повертати ї початковий вигляд.(той що був до сереалізації)
#     Відкриває наш файл для читання байт-рядків і за допомогою  метод *pickle.load(fh) 
#     Зчитуємо байт-дані і нормальний їх вигляд присвоюємо змінній contacts 
#     Повертаємо контакти з функції в їх початковому вигляді'''

#     with open(filename, "rb") as fh: # Відкрити файл з іменем *filename(шлях до файлу тип Path) 
#                                      # для читаннябайт-рядків з параметром "rb" - , Задопомогою менеджера контексту *with ... as
#         contacts = pickle.load(fh)   # Зчитуємо данні з файлового хендлера *fh і десерілізуємо їх за допомогою метода *pickle.load(fh)
#                                      # Присвоюємо десіралізовані дані зміній *contacts.
#     return contacts         # Повертаємо дані з функції



# # ================================ Звдання 2 / Task 2 ======================================

# # ================================  3.Серіалізація об'єктів Python за допомогою json  ==========================

# Протокол JSON (розшифровується як JavaScript Object Notation) дуже популярний в інтернеті протокол передачі. 
# Цей протокол має низку переваг:

# простий, його легко реалізувати;
# читабельний;
# відносно компактний (є набагато економніші протоколи).
# Перша перевага зробила JSON універсальним, будь-яка сучасна мова програмування підтримує JSON. 
# А якщо ні, то ви самі можете легко реалізувати підтримку JSON.

# Недоліки у JSON теж є:

# обмежений набір типів;
# ресурсомісткий (є і більш вимогливі до ресурсів протоколи).
# JSON підтримує такі типи даних:

# запис (як словник у Python), в якості ключа можуть бути тільки рядки, значення — будь-який JSON тип;
# масив (як список у Python);
# число (немає різниці між цілими чи дробовими);
# літерал (True, False, None);
# рядок.
# Як і у Python запис та масив можуть містити вкладені записи і/або словники будь-якої глибини вкладеності.

# Слід бути акуратним з конвертацією типів під час роботи з JSON у Python. 
# Кортежі під час розпакування з JSON стають списками, ключі словника, якщо вони були числами, стають рядками ж.

# Python підтримує JSON і в стандартному постачанні є пакет json, в якому є все необхідне для роботи з JSON.

# Методи dump та load зберігають дані у відкритий для запису файл і читають із відкритого для читання файлу.

# import json

# some_data = {'key': 'value', 2: [1, 2, 3], 'tuple': (5, 6), 'a': {'key': 'value'}}
# file_name = 'data.json'

# with open(file_name, "w") as fh:
#     json.dump(some_data, fh)

# with open(file_name, "r") as fh:
#     unpacked = json.load(fh)

# unpacked is some_data  # False
# unpacked == some_data  # False

# unpacked['key'] == some_data['key']  # True
# unpacked['a'] == some_data['a']  # True
# unpacked['2'] == some_data[2]  # True
# unpacked['tuple'] == [5, 6]  # True
# Результатом буде файл data.json із наступною структурою.

# {
#   "key": "value",
#   "2": [
#     1,
#     2,
#     3
#   ],
#   "tuple": [
#     5,
#     6
#   ],
#   "a": {
#     "key": "value"
#   }
# }

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

# {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів за допомогою пакету json 
# та зберігання отриманих даних у текстовому файлі.

# Перша функція write_contacts_to_file приймає два параметри: filename - ім'я файлу, contacts - список контактів. 
# Вона зберігає вказаний список у файл, використовуючи метод dump пакету json.

# Структура json файлу має бути такою:

# {
#   "contacts": [
#     {
#       "name": "Allen Raymond",
#       "email": "nulla.ante@vestibul.co.uk",
#       "phone": "(992) 914-3792",
#       "favorite": false
#     },
#     ...
#   ]
# }
# Тобто список контактів повинен зберігатися за ключем "contacts", а не просто зберегти список у файл.

# Друга функція read_contacts_from_file читає та повертає зазначений список contacts з файлу filename, 
# збереженого раніше функцією write_contacts_to_file, використовуючи метод load пакету json.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : завдання схоже на попереднє тільки тут використовуємо бібілотеку json 
#           і її методи серіалізації *json.dump і *json.load , які для запису і зчитування 
#           використовую звичайні типи дани,х а не байт рядки як попередня бібліотека *pickle 
            # Також є додаткова умова в завданні що дані мають бути записані в словник з ключем "contacts" що 
            # й і реалізуємо в коді. Щось додатково коментувати в цьому завдані потреби не бачу.

# import json

# def write_contacts_to_file(filename, contacts):
#     with open(filename, "w") as fh:
#         json_dict = {"contacts" : contacts}
#         json.dump(json_dict, fh)

# def read_contacts_from_file(filename):
#     with open(filename, "r") as fh:
#         json_dict = json.load(fh)
#         return json_dict["contacts"]



# # ================================ Звдання 3 / Task 3 ======================================

# # ================================  4.Робота з таблицями CSV у Python  ==========================

# Ще один формат обміну інформацією, що дуже часто використовується — це табличне уявлення. 
# Відкритий формат для зберігання табличних даних, який підтримується будь-яким редактором — це формат csv.
# Формат csv є, по суті, тим самим текстовим файлом, 
# але з умовою, що вся інформація в ньому розділена на колонки та рядки символами роздільниками. 
# Типово колонки поділяють комою, а рядки — символ нового рядка. Але можна використати будь-яку іншу комбінацію символів.

# Python підтримує роботу з табличними даними у форматі csv. Для цього у стандартному постачанні йде пакет csv.

# import csv

# with open('eggs.csv', 'w', newline='') as fh:
#     spam_writer = csv.writer(fh)
#     spam_writer.writerow(['Spam'] * 5 + ['Baked Beans'])
#     spam_writer.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])

# with open('eggs.csv', newline='') as fh:
#     spam_reader = csv.reader(fh)
#     for row in spam_reader:
#         print(', '.join(row))
# В результаті виконання цього коду в робочій папці з'явився файл eggs.csv. 
# Якщо відкриєте його табличним редактором, він відкриється як таблиця.

# Є два допоміжні класи в пакеті csv, які виконують роботу з табличними даними трохи зручніше:

# import csv

# with open('names.csv', 'w', newline='') as fh:
#     field_names = ['first_name', 'last_name']
#     writer = csv.DictWriter(fh, fieldnames=field_names)
#     writer.writeheader()
#     writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
#     writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
#     writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})

# with open('names.csv', newline='') as fh:
#     reader = csv.DictReader(fh)
#     for row in reader:
#         print(row['first_name'], row['last_name'])
# Класи DictWriter та DictReader дозволяють працювати з рядками таблиці як зі словниками, 
# де як ключі використовуються назви колонок (перший рядок).

# Таким чином за допомогою Python можна генерувати табличні дані та імпортувати дані з таблиць.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

#     {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів за допомогою пакету csv та 
# зберігання отриманих даних у текстовому файлі.

# Перша функція write_contacts_to_file приймає два параметри: 
# filename - ім'я файлу, contacts - список контактів. Вона зберігає вказаний список у файлі формату csv.

# Структура csv файлу має бути такою:

# name,email,phone,favorite
# Allen Raymond,nulla.ante@vestibul.co.uk,(992) 914-3792,False
# Chaim Lewis,dui.in@egetlacus.ca,(294) 840-6685,False
# Kennedy Lane,mattis.Cras@nonenimMauris.net,(542) 451-7038,True
# Wylie Pope,est@utquamvel.net,(692) 802-2949,False
# Cyrus Jackson,nibh@semsempererat.com,(501) 472-5218,True
# Зверніть увагу, першим рядком у файлі йдуть заголовки – це назви ключів.

# Друга функція read_contacts_from_file читає, 
# виконує перетворення даних та повертає вказаний список contacts із файлу filename, 
# збереженого раніше функцією write_contacts_to_file.

# Примітка: При читанні файлу csv ми отримуємо властивість словника favorite у вигляді рядка, тобто. 
# наприклад favorite='False' . 
# Необхідно його привести до логічного виразу назад, щоб стало favorite=False.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# *Примітка :# Ще один формат обміну інформацією, що дуже часто використовується — це табличне уявлення. 
             # Відкритий формат для зберігання табличних даних, який підтримується будь-яким редактором — це формат csv.
             # Формат csv є, по суті, тим самим текстовим файлом, 
             # але з умовою, що вся інформація в ньому розділена на колонки та рядки символами роздільниками. 
             # Типово колонки поділяють комою, а рядки — символ нового рядка. Але можна використати будь-яку іншу комбінацію символів.
             # Python підтримує роботу з табличними даними у форматі csv. Для цього у стандартному постачанні йде пакет csv

# import csv # Імпортуємо вбудований пакет *csv в Python



# def write_contacts_to_file(filename, contacts):
#     '''Власна функція для конвертації і запису даних в csv-форматі з файлу з розширенням *.csv. 
#     де дані є  список з елементами - словники.
#     Тобто дані передані з списку *contacts пертворює в csv-формат і записує в файл з іменем що мітиться в *filename
#     Запис в файл відбувається з параметром 'w'. Отже файл потрібного формату має бути створений на диску , 
#     і він буде постійно перезаписуватись наново при кжному виклику функції *write_contacts_to_file(filename, contacts)
#     Приймає два аргумента: 
#       *filename - імя файлу з розширенням *.csv в який буде записувати дані .
#       *contacts - дані які будемо записувати в файл, 
#             В нашому випадку список, де кожен елемент словник встановленого формату(дивись умову задачі)
#             '''

#     with open(filename, 'w', newline='') as fh: # відкриваємо файл  з  іменем з *filename для запису з парметром *'w', 
#                                                 # і додатковим параметром *newline=''- цей параметер вказує на те що запис в файл буде робитись рядок за рядком, 
#                                                 # якщо параметр *newline='' - невказаний, запис у файл відбувається через пустий рядок.(дані, пустий_рядок,дані, пустий_рядок) 

#         field_names = ["name", "email", "phone", "favorite"] # Формуємо перше поле для запису в форматі *.csv , Це має бути - header(шапка) 
#                                     # Тут перечисляємо ключі словника щоб утворити загаловок таблиці .
#                                     # Важливо щоб ці ключі були такі як і ключі в словниках які будуть передаватись для формування таблиці.
#                                     # Інакше кажучи Дані які будемо записувати в *.csv-форматі Бажано щоб були однакового формату. 
#                                     # Тобто містили такі ж ключі, і таку ж їх кількість як у заголовку таблиці .
#                                     # В нашому випадку в списку *field_names. Детальніше читай в інтернеті щоб буде якщо дані не будуть порібного формату.    
        

#         writer = csv.DictWriter(fh, fieldnames=field_names) # Створюємо екзепляр класу *<class 'csv.DictWriter'> з іменем *writer , 
#                                                             # за допомогою вбудованого модуля класу *DictWriter(fh, fieldnames=field_names) пакету *csv.
#                                                             # де fh - файловий хендлер , і fieldnames= - список ключів(заголовків таблиці),
#                                                             # Які ще аргументи і які поля та методи має клас *DictWriter читай в інтренеті.
# # Примітка : оскільки ми імпортували весь пакет *csv то виклик потрібного нам модуля *DictWriter  відбувається через крапку. *csv.DictWriter 
#             # Шаблон виклику (*імя_пакету.*імя_його_модуля)
                                                            
#         #print(type(writer)) # *<class 'csv.DictWriter'> # тестовий принт(для себе ) щоб переконатись що екзепляр потрібного класу.
        
#         writer.writeheader() # Метод *.writeheader() - класу 'csv.DictWriter' , 
#                              # Записує перший рядок в csv-файл, Заголовки-ключі таблиці , Тобто те що містить аргумент *fieldnames 
#         writer.writerows(contacts) # Метод *.writerows(*якісь_ітерабельні_днані) , 
#                                    # Проводить запис відразу всіх переданих даних у csv -файл-таблицю. Де кожен елемент запишеться з нового рядка.
#                                    # В нашому випадку *contacts - це список з елементами якого є словники відповідного формату.
#                                    # Тому ми використовуємо клас *DictWriter- клас для запису словників в csv-(файл-таблицю).
# # Таблиця буде мати наступний вигляд : 
#         # Перший рядок завжди (рядок заголовків-ключів): name,email,phone,favorite
#         # Наступні рядки - Значення відповідних ключів з переданих словників отримані за ключами з заголовку.
       
#         # name,email,phone,favorite 
#         # Allen Raymond,nulla.ante@vestibul.co.uk,(992) 914-3792,False
#         # Chaim Lewis,dui.in@egetlacus.ca,(294) 840-6685,False     
                                    
        

# def read_contacts_from_file(filename):
#     '''Функція для читання і конвертації даних в csv-форматі з файлу з розширенням *.csv. 
#     в список з елементами - словники. 
#     Фактично виконує обернену дію до  *write_contacts_to_file(filename, contacts)
#     Приймає один аргумент, імя_файлу що містять конвертовані дані *csv-формат (дані csv-формат типу словники)
#     Для зчитування будемо використовувати клас *DictReader пакету *csv - клас конвертації даних з *csv-формату в словники  
#     Конвертовані словники будемо добавляти в список , список елементи якого є словники повертаємо з функції.
# *Примітка : під час конвертації даних в сsv формат всі дані стають рядками(тип *str) , коли конвертуємо назад дані то вони повернуться як рядки (тип *str).
#     Тому ті дані які мають мати інший тип, потрібно переприсвоїти через функцію  *eval(*str)
#     *eval(*str) - конвертує дані з *str в початковий тип. Якщо коверт не можливий повертає помилку  '''

#     with open(filename,'r', newline='') as fh: # Відкримаємо наш файл з іменм що міститься в *filename , для читання - параметр "r"
#                                                # і параметром newline='' (*вказано що потрібно цей пераметр щоб коректно зчитувати дані з файла *.csv, хоча для зчитування він мабуть необовязковий.) 
#         reader = csv.DictReader(fh) # Створюємо ітерабельний екзепляр класу <class 'csv.DictReader'> з іменем *reader
#                                     # атрибути якого будуть містити конвертовані дані з csv-файла.(підсказка -словники)
#         #print(type(reader))  # Тестовий прітнт Дляконтрою значеннь
#         list_contacts = [] # Список в який будемо додавати наші елементи (конвертовані з csv-файла словники)
        
#         for row in reader: # оскільки наш екзепляр *reader класу <class 'csv.DictReader'> ітерабельний(створюється таким позамочуванню)
#                            # То ми можемо пройтись по ньому циклом. на кожній ітерації циклу буде повертати словник 
#                            # cформований з ключами із заголовків і відповідними їх значеннями з таблиці *csv-файлу
#                            # Приклад : {'name':'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': 'False'}
            
#             row["favorite"] = eval(row["favorite"]) # Повертаємо кючу "favorite" його початкове значення за допомогою вбудованої функції *eval(*str)(читай опис вищеабо в інтрнеті)
#                                                     # Було 'favorite': "False"(значення тип *str)-  стане 'favorite': False (значення тип *bool)
#             list_contacts.append(row) # На кожній ітерації циклу добавляємо наш приведений до початковго стану словник в спиок контактів *list_contacts
#     return list_contacts # Повертаємо сформований список контактів де кожний елемент буде словником вказаного формату з функції.

#  # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++              

# filename = "csv_file.csv" # Створений файл з розширенням *.csv для тестових вправ. Файл створюємо в папці де мітиться код в якому плануємо його використовувати, інакше потрібно вказувати шлях до  файлу.
# contacts =  [{'name':'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': False},
#              {'name': 'Chaim Lewis', 'email': 'dui.in@egetlacus.ca', 'phone': '(294) 840-6685', 'favorite': True}]

# write_contacts_to_file(filename , contacts) # Викликаємо функцію *write_contacts_to_file і передаємо її потрібні аргументи.
#                                             # вміст файлу csv_file.csv  переглядаємо за допомогою блокнота чи екселя або інших файлофих редакторів які можуть читати цей формат.
#                                             # Примітка : Якщо відкрити цей файл в vs_code .буде видно тільки запис *data
# print (read_contacts_from_file(filename))  # Принтимо результат . Перевіряємо чи він співпадає з ти що в *contacts ,Все відпрацювало як треба , автоперевіка прийняла результат.

# # [{'name': 'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': False}, 
# # {'name': 'Chaim Lewis', 'email': 'dui.in@egetlacus.ca', 'phone': '(294) 840-6685', 'favorite': True}]

# # ================================ Звдання 4 / Task 4 ======================================

# # ================================  2.Серіалізація об'єктів Python за допомогою pickle  ==========================

# Ви можете зберігати об'єкти для подальшого використання, але за умови, 
# щоб pickle міг коректно зберегти, а потім розпакувати упакований об'єкт класу, 
# необхідно, щоб сам клас був оголошений раніше у коді, де відбувається розпакування.

# import pickle


# class Human:
#     def __init__(self, name):
#         self.name = name


# bob = Human("Bob")
# encoded_bob = pickle.dumps(bob)

# decoded_bob = pickle.loads(encoded_bob)

# bob.name == decoded_bob.name  # True
# Але якби ви захотіли передати об'єкт bob по мережі іншому комп'ютеру, 
# який нічого не знає про клас Human, то ви отримаєте помилку.
# Якщо ж на обох кінцях каналу зв'язку оголошено клас Human, то такий обмін працюватиме.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Приклад створення екземпляра класу:

#     Person(
#     "Allen Raymond",
#     "nulla.ante@vestibul.co.uk",
#     "(992) 914-3792",
#     False,
# )
# Розробіть клас Contacts. Він повинен ініціалізувати через конструктор дві властивості: 
# filename - ім'я файлу для пакування об'єкта класу Contacts, contacts - список контактів, екземплярів класу Person.

# Приклад створення екземпляра класу:

# contacts = [
#     Person(
#         "Allen Raymond",
#         "nulla.ante@vestibul.co.uk",
#         "(992) 914-3792",
#         False,
#     ),
#     Person(
#         "Chaim Lewis",
#         "dui.in@egetlacus.ca",
#         "(294) 840-6685",
#         False,
#     ),
# ]

# persons = Contacts("user_class.dat", contacts)
# Розробіть два методи для серіалізації та десеріалізації екземпляра класу Contacts за допомогою пакету pickle 
# та зберігання даних у бінарному файлі.

# Перший метод save_to_file зберігає екземпляр класу Contacts у файл, використовуючи метод dump пакету pickle. 
# Ім'я файлу зберігається в атрибуті filename.

# Другий метод read_from_file читає та повертає екземпляр класу Contacts з файлу filename, 
# використовуючи метод load пакету pickle.

# Приклад роботи:

# persons = Contacts("user_class.dat", contacts)
# persons.save_to_file()
# person_from_file = persons.read_from_file()
# print(persons == person_from_file)  # False
# print(persons.contacts[0] == person_from_file.contacts[0])  # False
# print(persons.contacts[0].name == person_from_file.contacts[0].name)  # True
# print(persons.contacts[0].email == person_from_file.contacts[0].email)  # True
# print(persons.contacts[0].phone == person_from_file.contacts[0].phone)  # True

# +++++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# import pickle # Модуль pickle реалізує двійкові протоколи для серіалізації та десеріалізації структури об’єктів Python. 
#               # «Pickling» - це процес, за допомогою якого ієрархія об’єктів Python перетворюється на потік байтів, 
#               # а «unpickling» - це зворотна операція, за допомогою якої потік байтів (з binary file або bytes-like object) перетворюється назад в ієрархію об’єктів. Травлення (і розбирання) також відоме як «серіалізація», «маршалінг», [1] або «зведення»; однак, щоб уникнути плутанини, тут використовуються терміни «маринування» та «розмаринування».


# class Person:
#     '''Клас -даних.
#     Має свій конструктор в якому реалізовано 4 обовязкові поля:
#     *name, *email, *phone, *favorite
#     Клас для зберігання даних про особу.
#         '''
#     def __init__(self, name: str, email: str, phone: str, favorite: bool):
#         self.name  = name
#         self.email = email
#         self.phone = phone
#         self.favorite = favorite


  
# class Contacts:
#     '''Клас контактів - Виконує серіалізацію і зберігання даних у файл, а також вивантаження та десеріалізацію даних з нього, 
#      Має свій конструктор в якому реалізовано 2 обовязкові поля: 
#      *filename - імя файлу в який будемо зберігати і вигружати з нього дані про особу.
#      *contacts - список елементи якого будуть екзепляри класу *Person  
#     Також має два власних методи:
#     *save_to_file(self) -   Виконує серіалізацію і зберігання даних у файл
#     *read_from_file(self) - Виконує вивантаження та десеріалізацію даних з файлу  '''
#     def __init__(self, filename: str, contacts: list[Person] = None):
        
#         if contacts is None: # Перевіряємо чи передались дані в аргумент *contacts, якщо ні- *contacts буде містити занчення позамовчуванню *None
#             contacts = []    # Якщо умова виконалась, значить аргумент *contacts непередався, отже встановлюємо *contacts = []  
#         #print(type(contacts)) # Тестовий принт для контрою значення (для себе)
#         self.contacts = contacts
#         self.filename = filename

#     def save_to_file(self):
#         '''Метод без аргументів - 
#         Виконує серіалізацію за допомогою вбудованого методу *pickle.dump(*обєкт/екзепляр, **файловий_дискриптор) пакету *pickle 
#         і зберігання даних у файл '''
        
#         #print(type(self.contacts)) # Тестовий принт для контрою значення (для себе)
#         with open(self.filename, "wb") as fh:  # Відкриваємо файл для запису в байт-рядки *"wb" ,за допомогою менеджера контексту *with ...as
#             pickle.dump(self, fh)  # Виконуємо серіалізацію за допомогою вбудованого методу *pickle.dump(*обєкт/екзепляр, *файловий_дискриптор) пакету *pickle
#                                    # Де *self(посилання на самого себе ) - екзепляр класу *Contacts , *fh- *файловий_дискриптор.
#     def read_from_file(self):
#         '''Метод без аргументів - 
#         Виконує вивантаження даних з файлу і десеріалізацію за допомогою вбудованого методу *pickle.load(*файловий_дискриптор) пакету *pickle 
#         '''
#         with open(self.filename, "rb") as fh: # Відкриваємо файл для зчитування в байт-рядків *"rb" , за допомогою менеджера контексту *with ...as

#             result = pickle.load(fh) # Виконуємо десеріалізацію за допомогою вбудованого методу *pickle.load(**файловий_дискриптор) пакету *pickle
#                                      # Десеріалзовані дані присвоюємо змінній *result(буде мітити початкові дані які були до серіалізовані) 
        
#         return result # Обєкт класу *Contacts вигляду *<__main__.Contacts object at 0x000001C60FD5BD40>
        
    
# #  # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++
        
# filename = "My_class_contacts.dat" # Створений файл з розширенням *.dat для тестових вправ. Файл створюємо в папці де мітиться код в якому плануємо його використовувати, інакше потрібно вказувати шлях до  файлу.

# # persons = Person("Allen Raymond","nulla.ante@vestibul.co.uk","(992) 914-3792", False)

# contacts = [Person( "Allen Raymond", "nulla.ante@vestibul.co.uk", "(992) 914-3792", False,), 
#             Person("Chaim Lewis","dui.in@egetlacus.ca", "(294) 840-6685", False,)]

# persons = Contacts("My_class_contacts.dat", contacts) # Створюємо екзепляр класу *Contacts з іменем *persons 
# persons.save_to_file() # Перевіряємо у файлі чи відбувся запис даних, в VS_Code можна глянути відразу
# person_from_file = persons.read_from_file() # Присвоюємо *person_from_file екзепляр класу *Contacts десеріалізований з файлу "My_class_contacts.dat".
#                                             # *person_from_file - це буде новий екзепляр класу *Contacts про те всі поля будуть містити індентичнч дані що й і оріганал.
# print (person_from_file)  # <__main__.Contacts object at 0x000002585BABBD40>
# print(persons == person_from_file)  # False  # Порівнюємо орігінальний екзепляр з його клонм після десеріалізації. Буде False бо це різні обєекти.
# print(persons.contacts[0] == person_from_file.contacts[0])  # False . # Буде False бо в кожного екзепляра свої посилання на однакові поля.
# print(persons.contacts[0].name == person_from_file.contacts[0].name)    # True # Буде True бо значення будуть одинакові
# print(persons.contacts[0].email == person_from_file.contacts[0].email)  # True # Буде True бо значення будуть одинакові
# print(persons.contacts[0].phone == person_from_file.contacts[0].phone)  # True # Буде True бо значення будуть одинакові



# # ================================ Звдання 5 / Task 5 ======================================

 # ================================  5.Управління порядком серіалізації ,Серіалізація об'єктів Python за допомогою pickle  ==========================

#+++++++++++++++++++++  Магічний метод *__getstate__(self)(Метод де можна корегувати дані до підчас сереалізації) ++++++++++++++++++++++++++++++++++++

# Не всі об'єкти Python можна серіалізувати. 
# Наприклад, не можна серіалізувати файловий дескриптор або системний ресурс. 
# Але що робити, коли у вас є клас, об'єкт якого ви хочете запакувати, використовуючи pickle, 
# але у нього є атрибути, що не серіалізуються? У такій ситуації ви можете скористатися магічними методами, 
# які керують серіалізацією та десеріалізацією за допомогою pickle.

# Магічний метод __getstate__ викликається, коли pickle намагається отримати представлення об'єкта у вигляді byte-рядку. 
# У звичайній реалізації __getstate__ повертає __dict__ словник, де зберігаються всі атрибути класу. 
# Але ви можете змінити цей метод.

# import pickle


# class Reader:
#     def __init__(self, file):
#         self.file = file
#         self.fh = open(self.file)
#         self.position = 0

#     def close(self):
#         self.fh.close()

#     def read(self, size=1):
#         data = self.fh.read(size)
#         self.position = self.fh.tell()
#         return data

#     def __getstate__(self):
#         attributes = self.__dict__.copy()
#         attributes['fh'] = None
#         return attributes
# У цьому прикладі клас Reader можна серіалізувати, помилки через неможливість упакувати файловий дескриптор не виникне.

# # ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Ми продовжимо розширювати приклад попереднього завдання. Додайте до класу Contacts атрибут count_save, 
# за замовчуванням він повинен мати значення 0. Реалізуйте магічний метод __getstate__ для класу Contacts. 
# При упаковуванні екземпляра метод класу повинен збільшувати значення атрибута count_save на одиницю. 
# Таким чином, ця властивість - лічильник повторних операцій пакування екземпляра класу

# Приклад роботи коду:

# persons = Contacts("user_class.dat", contacts)
# persons.save_to_file()
# first = persons.read_from_file()
# first.save_to_file()
# second = first.read_from_file()
# second.save_to_file()
# third = second.read_from_file()

# print(persons.count_save)  # 0
# print(first.count_save)  # 1
# print(second.count_save)  # 2
# print(third.count_save)  # 3


# +++++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка :  Із новго тільки Магічний метод *__getstate__ .В цьому завдані не розкривається його суть 
            # не зрозуміло для чого він тут. Все працює і без нього , можливо він потрібний для надійності , 
            # у випадках коли серіалізація піде не так , виникне якийсь системний збій на рівні Операціїної системи , чи чогось іншого.
            # Поки логіка підсказує тільки два варіанта. 
            # Перше: Щоб ми бачили що так можна і так можливо правильно робити щоб захиститись від всіх можливих "нещасних" випадків .
            # Друге: При упаковуванні екземпляра метод класу повинен збільшувати значення атрибута count_save на одиницю. 
                    # Таким чином, ця властивість - лічильник повторних операцій пакування екземпляра класу
 #Примітка : # Тут потрібно збільшувати count_save саме для збереженного обʼєкта, не для поточного
             # Для себе реалізував ще лічильник поточного екзкпляра *self.count_save_potoch - 
             # щоб побачити чим відрізняються для завдання непотрібно але автоперевірці нешкодить
 


# import pickle


# class Person:
#     def __init__(self, name: str, email: str, phone: str, favorite: bool):
#         self.name = name
#         self.email = email
#         self.phone = phone
#         self.favorite = favorite


# class Contacts:

    
#     def __init__(self, filename: str, contacts: list[Person] = None):
#         if contacts is None:
#             contacts = []
#         self.filename = filename
#         self.contacts = contacts
#         self.count_save = 0
#         self.count_save_potoch = 0
        
        
        

#     def save_to_file(self):
#         with open(self.filename, "wb") as file:
#             pickle.dump(self, file)
            

#     def read_from_file(self):
#         with open(self.filename, "rb") as file:
#             content = pickle.load(file)
            
#         return content

#     def __getstate__(self):
#         '''Дещо зкорегований магічний метод без аргументів, 
#          Орігінал відповідає за перевірку даних які будуть серіалізуватись в пакеті *pickle(може не тільки),
#          не можна серіалізувати файловий дескриптор або системний ресурс (взято з теорії)  .
#          Тому ми реалізуємо свій який буде обходити цю проблему 
#            В нашому випадку полю 'file'(так називається наш файловий дискриптор) присвоємо значення *None
#          '''
#         attributes = self.__dict__.copy() # Присвоюємо якійсь змінні *attributes копію словника (того що буде утворюватись підчас серіалізаці )
#                                           # *self.__dict__.copy() - цей запис це поислання на оригінальний словник (той що створюється під капотом підчас серіалізаії)
#                                           # оскільки магічний метод *__getstate__ перевіряє вхідні дані до того як вони попадуть вцей словник то ми можемо їх опрацювати і повернути назад вже з методу .
#         attributes['file'] = None # Присвоюємо ключу 'file' з словника *attributes  значення *None  
#         attributes['count_save'] += 1 # лічильник повторних операцій пакування екземпляра класу
#         self.count_save_potoch += 1   # лічильник поточного екзкпляра(рахує скільки развикликався метод *save_to_file(), 
#             #якщо новий екзепляр буде копією поточного то він успадкує початкове значення від батьківського екзепляра )
#         return attributes # Повертаємо наш модивікований словник в *save_to_file() для виконання серіалізації і збереження в файл.

# # #  # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++

# contacts = [Person( "Allen Raymond", "nulla.ante@vestibul.co.uk", "(992) 914-3792", False,), 
#             Person("Chaim Lewis","dui.in@egetlacus.ca", "(294) 840-6685", False,)]


# persons = Contacts("user_class.dat", contacts) # Створення екзепляра *persons Класу *Contacts, з заданих даних
# persons.save_to_file() # Викликаємо метод *.save_to_file()  для серіалізації і збереження в файл.
# persons.save_to_file() # Викликаємо метод *.save_to_file()  для серіалізації і збереження в файл.(ще оди виклик щоб побачити як відпрацюють лічильники)
 
# first = persons.read_from_file() # Створюємо новий екзепляр *first , методом копіювання вже створеного екзепляра *persons
# # Примітка :перед копіюванням, дані повернемо з файла методом *.read_from_file() десеріалізації 
# # щоб переконатись що отримаємо початковий екзепляр а не щось інше ).
# first.save_to_file() # Викликаємо метод *.save_to_file()  для серіалізації і збереження в файл нашої першої копії *first

# second = first.read_from_file() #  Створюємо новий екзепляр *second , методом копіювання *first.read_from_file() першої копії від оригінала *persons
# second.save_to_file()           # Викликаємо метод *.save_to_file()  для серіалізації і збереження в файл нашої першої копії від *first і другої від *persons

# third = second.read_from_file() # Створюємо новий екзепляр *third , методом копіювання *second.read_from_file() першої копії від *second, 
# # другої копії від *first, і третьої копії від від оригінала *persons

# print(f"Persons_count_save = {persons.count_save}")  # 0 # Оригінал *persons лічильник *count_save == 0
# print(f"Persons_count_save_potoch = {persons.count_save_potoch}") # 2 # 
#         #Оригінал *persons лічильник *count_save_potoch == 2 
#         # бо вище в коді ми спеціально викликали два рази метод *.save_to_file()для цього екзепляра щоб первірити роботу лічильника *count_save_potoch 
#         # відпрацював штатно, два рази викликали *.save_to_file() - лічильник *count_save_potoch == 2 в занченнях отримав 2 )

# print(f"First_count_save = {first.count_save}")  # 1 # Перша копія від оригіналу *first, count_save == 1 . Збільшився на 1 (Є припущення що цей лічильник вказує на те яка це копія від оригіналу)
#                                                      # Перша копія тому можливо і *count_save == 1 . відпрацював штатно.
# print(f"First_count_save_potoch = {first.count_save_potoch}") # 2 # first.count_save_potoch == 2 перша копія від оигнала .
#             # Відпрацював нештатно . Бо ми один раз тільки викликали *first.save_to_file() , а *.count_save_potoch містить 2 . Значить успадкував мабуть початкові дані від орігіналу і добавив свій

# print(f"Second_count_save = {second.count_save}")  # 2 # Копія з копії . Тому count_save == 2
# print(f"Second_count_save_potoch = {second.count_save_potoch}") # 2 # успадкував 1 від першої копії добавив один свій (один раз викликали для цього екзепляра *save_to_file())

# print(f"Third_count_save = {third.count_save}")  # 3 # Копія з другої копії . Тому count_save == 3
# print(f"Third_count_save_potoch = {third.count_save_potoch}") # 1 # Успадкував 1 від 2 копії сам методу *.save_to_file() для цього екзепляра невикликали тому 1 і залишився успадкованим.

# # *Примітка : Що від чого успадковано і чи правильна моя логіка потрібно перевіряти . 
# #  Можна подобавляти різну кількість викликів і перевірити як будуть мінятись ці лічильник. Де зміни в одному будуть впливати на всіх а де ні .
# # Якщо колись буде потреба з цим розібратись потрібно по експерементувати . Особливість цих прикладів в тому що ту нові екзепляри утворюються з попередніх, а не з нових занчень.  


# # ================================ Звдання 6 / Task 6 ======================================

 # ================================   5.Управління порядком десеріалізації ,Серіалізація об'єктів Python за допомогою pickle ==========================

# +++++++++++++++++++++ Магічний метод *__setstate__(self, value)(Метод де можна корегувати дані  під час десереалізації)


# Цей магічний метод отримує на вхід словник, розпакований з файлу або byte-рядку. 
# Поведінка за замовчуванням — це записати отримане значення в self.__dict__.
# Давайте доопрацюємо клас Reader так, щоб він міг після розпакування продовжити читання з того ж місця.

# import pickle


# class Reader:
#     def __init__(self, file):
#         self.file = file
#         self.fh = open(self.file)
#         self.position = 0

#     def close(self):
#         self.fh.close()

#     def read(self, size=1):
#         data = self.fh.read(size)
#         self.position = self.fh.tell()
#         return data

#     def __getstate__(self):
#         attributes = {**self.__dict__}
#         attributes['fh'] = None
#         return attributes

#     def __setstate__(self, value):
#         self.__dict__ = value
#         self.fh = open(value['file'])
#         self.fh.seek(value['position'])

# # ++++++++++++++++++++++++++++++++++++++  Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Продовжуємо розширювати приклад із попереднього завдання.
# Додайте до класу Contacts атрибут is_unpacking, за замовчуванням він повинен мати значення False. 
# Реалізуйте магічний метод __setstate__ для класу Contacts. 
# При розпаковуванні екземпляра класу метод повинен змінювати значення атрибута is_unpacking на значення True. 
# Таким чином, ця властивість визначатиме, що екземпляр класу отримано внаслідок розпакування.

# Приклад роботи коду:

# persons = Contacts("user_class.dat", contacts)
# persons.save_to_file()
# person_from_file = persons.read_from_file()
# print(persons.is_unpacking)  # False
# print(person_from_file.is_unpacking)  # True


# +++++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Із нового добавили поле *self.is_unpacking = False з значенням за замовчуванням  False.
#            І зкорегували інший магічний метод *__setstate__(self, value) який використовується при розпакуванні з файла даних
#            Саме він відповідає за повернення словника при розпакуванні з файла в пакеті/класі *pickle
#             Детальніше про пакет і його магічні методи читай в документації https://docs.python.org/uk/3/library/pickle.html
#             або шукай в інтернеті.
# Прмітка : Всі ці магічні методи (імя яких починається і закінчується подвійним підкресленням *__імя_методу__) - 
#           - це те що відбувається підкапотом в Середані самого Paython . 
#             До майже всіх цих методів ми маємо доступ для корегування їх поведінки в своєму коді.
#             Просто їх потрібно викликати в совєму класі і задати їм відповідну поведінку. 
#             Тоді всі екзепляри вашого класу будуть поводити себе як вам треба а не як передбачає їх стандартна поведінка.
#             Всі ці зміни будуть діяти тільки для цих екзеплярів і ніякого впливу на інших мати не будуть. 
#             Це дозволяє робити все що вам хочиться для своїх потреб . Потрібно тільки знати магічний метод і за що він відповідає 
#             Далі зкорегувати його поведінку і замість 2 + 2 можна виводи 5 (чи буть що інше ) для даних свого екзкпляру .
#             (*Прмітка для себе ))).

# import pickle


# class Person:
#     def __init__(self, name: str, email: str, phone: str, favorite: bool):
#         self.name = name
#         self.email = email
#         self.phone = phone
#         self.favorite = favorite


# class Contacts:
#     def __init__(self, filename: str, contacts: list[Person] = None):
#         if contacts is None:
#             contacts = []
#         self.filename = filename
#         self.contacts = contacts
#         self.count_save = 0
#         self.is_unpacking = False # задаємо нове поле в нашому екзеплярі . Значення за замовчуванням *False
        

#     def save_to_file(self):
#         with open(self.filename, "wb") as file:
#             pickle.dump(self, file)

#     def read_from_file(self):
#         with open(self.filename, "rb") as file:
#             content = pickle.load(file)
#         return content

#     def __getstate__(self):
        
#         attributes = self.__dict__.copy()
#         attributes["count_save"] = attributes["count_save"] + 1
#         return attributes

#     def __setstate__(self, value):
#         '''Модифікуємо магічний метод *__setstate__, пакету *pickle, який відповідає за повернення словника з файлу під час десерелізації
#          Приймає один аргумент, сам словник який повертається підчас десереалізації з файлу
#          і преприсвоює магічному методу екзепляра *self.__dict__(тобто вже якомусь конкретному екзепляру )
#         Перед тим як словник присвоється екзепляру ми вносимо зміни в занчення ключа 'is_unpacking' - записуємо туди *True 
#          і вже зкорегований словник встановлюємо конкретному екзепляру 
#     *Примітка : всі корекції ключів вносимо до присвоєння словника *value словнику екзепляра.
#             Тобто вище за *self.__dict__ = value
#     *Примітка: всі атрибути які є в класі будуть в словнику, під час сереалізації і десереалізації, -
#               # ключами p відповідними їх значеннями.
#                  '''
#         value['is_unpacking'] = True # Встановлюємо словнику *value(словник створюється під час десеріалізації і передається як  аргумент магічного методу *__setstate__  ) 
#                                      # за ключем 'is_unpacking' значення True
        
#         self.__dict__ = value # Прсвоюємо наш словник *value, якомусь словнику екзепляру класу - *self.__dict__ . 
#                               # після цього вже інші магічні методи(деталі читай в документації *pickle)  перероблять всі ключі з цього словника  знову в поля і методи класу що десереалізуємо і 
#                               # наш екзепляр якому будемо присвоювати результат  набуде всіх форм і значень цього класу.
        
        
        


# # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++


# contacts = [Person( "Allen Raymond", "nulla.ante@vestibul.co.uk", "(992) 914-3792", False,), 
#             Person("Chaim Lewis","dui.in@egetlacus.ca", "(294) 840-6685", False,)]
        
# persons = Contacts("user_class.dat", contacts) # Створення екзепляра *persons Класу *Contacts, з заданих даних 
# persons.save_to_file()                         # Викликаємо метод *.save_to_file()  для серіалізації і збереження в файл.
# person_from_file = persons.read_from_file()    # Викликаємо метод *.read_from_file()  для десеріалізації і вивантаження 
#                                                # збережених раніше у  файл даних екзепляру *persons і присвоюємо їх новому екзепляру *person_from_file
# print(persons.is_unpacking)  # False  # Прінтимо значення поля *is_unpacking для оригінала *prerson . Як бачимо статус не змінився  
# print(person_from_file.is_unpacking)  # True # Прінтимо значення поля *is_unpacking для для копії *person_from_file і бачимо що стус змінився .
#             # Бо саме під час створення копії і викличиться наш відкорегований магічний метод *__setstate__(self, value) 
#             # та поміняє вміст ключа *is_unpacking а значить і відповідного поля в новому екзеплярі на True.
#             # Тобто оригінал буде зберігати значення поля *is_unpacking - *False . Всs його копії буть мати *True

# person_from_file_1 = persons.read_from_file() 
# print(persons.is_unpacking)                     # False # Оригінал.
# print(person_from_file_1.is_unpacking)          # True # копія з оригіналу.

# person_from_file_2 = person_from_file_1 # створюємо копію з копії.
# print(person_from_file_2.is_unpacking)          # True # копію з копії також буде мати значення поля  *.is_unpacking - True
# print(persons.is_unpacking)                     # False # Як бачимо оригінал значення поля *.is_unpacking не міняє .Бо він не копія (для себе)


# # ================================ Звдання 7 / Task 7 ======================================

 # ================================  Створення копій обєктів . Пакет Copy  ==========================


# Python намагається заощаджувати пам'ять і не копіювати дані з однієї області пам'яті до іншої. 
# Натомість інтерпретатор створює нове посилання (ще один псевдонім) на об'єкт, що існує, замість копіювання вмісту.

# Така поведінка може призводити до помилок, коли справа стосується змінюваних типів, словників, списків, користувацьких класів.

# Щоб розв'язувати цю проблему, Python має механізм копіювання — це функції з пакета copy.

# Щоб створити "поверхневу" копію об'єкта, у пакеті copy є функція copy. 
# Ця функція створює новий об'єкт такого ж типу і потім створює посилання весь вміст старого об'єкта в новий. 
# Такий механізм досить гарний для роботи з об'єктами, де вже на першому рівні вкладеності немає змінних об'єктів,
# і вона працює досить швидко. Але для об'єктів із глибокою вкладеністю така функція все ж таки не дасть потрібного ефекту:

# import copy

# my_list = [1, 2, {1: 'a'}]
# copy_list = copy.copy(my_list)
# copy_list.append(4)
# print(my_list)  # [1, 2, {1: 'a'}]
# print(copy_list)  # [1, 2, {1: 'a'}, 4]

# copy_list[2][2] = 'b'
# print(my_list)  # [1, 2, {1: 'a', 2: 'b'}]
# З цього прикладу видно, що хоч copy_list вже є новим об'єктом (не посилання на my_list), 
# але вкладений у нього словник з індексом 2 — це один і той же словник і в copy_list, і в my_list.

# # ++++++++++++++++++++++++++++++++++++++  Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Для копіювання екземпляра класу Person із попереднього прикладу реалізуйте функцію copy_class_person. 
# Як параметр вона приймає екземпляр класу person, 
# та повертає "поверхневу" копію об'єкта за допомогою функції copy із пакета copy.

# Приклад коду:

# person = Person(
#     "Allen Raymond",
#     "nulla.ante@vestibul.co.uk",
#     "(992) 914-3792",
#     False,
# )

# copy_person = copy_class_person(person)

# print(copy_person == person)  # False
# print(copy_person.name == person.name)  # True
# ...


# +++++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : функції з пакета copy.

# Щоб створити "поверхневу" копію об'єкта, у пакеті copy є функція copy. 
# Ця функція створює новий об'єкт такого ж типу і потім створює посилання весь вміст старого об'єкта в новий. 
# Такий механізм досить гарний для роботи з об'єктами, де вже на першому рівні вкладеності немає змінних об'єктів,
# і вона працює досить швидко. Але для об'єктів із глибокою вкладеністю така функція все ж таки не дасть потрібного ефекту:

# import copy  # Імпортуємо пакет  *copy


# class Person:
#     def __init__(self, name: str, email: str, phone: str, favorite: bool):
#         self.name = name
#         self.email = email
#         self.phone = phone
#         self.favorite = favorite


# def copy_class_person(person):
#     '''Власна функція яка робити копію екзепляру класу і повертає її .
#     Приймає один аргумент , повертає його копію.
#     Ще таке копія обєекту і які вона буде мати властивості читай в теорії .'''
    
#     copy_class = copy.copy(person) # З пакету *copy викликаємо його функцію *copy . Просто робить копію всьго до чого застосовується.
#                                    # Копія це вже буде інший обєкт , про те значення буде мати такіж як і оригінал. 
#                                    # Деталі читай теорію або в інтернеті.
#     return copy_class  # Повертаємо копію з методу.


# +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++

# person = Person(
#     "Allen Raymond",
#     "nulla.ante@vestibul.co.uk",
#     "(992) 914-3792",
#     False,
# ) - #  Створюємо екзепляр класу *Person з іменем *person

# copy_person = copy_class_person(person) # Створюємо новий обєект класу за допомогою власної функції  копіювання.

# print(copy_person == person)  # False           # Буде *False  бо це різні обєкти .
# print(copy_person.name == person.name)  # True  # Буде *True бо значення одноімених полів в копіях будуть одинаковими.


# # ================================ Звдання 8 / Task 8 ======================================

 # ================================  Створення копій обєктів . Пакет Copy . deepcopy(Повна копія . і самих обєктів і їх значень) ==========================

# Для ситуацій, коли нам потрібно, щоб на будь-якому рівні вкладеності створювалися нові об'єкти, 
# а не посилання на ті що існують, у пакеті copy є функція deepcopy. Ця функція створює рекурсивно нові об'єкти.

# import copy

# my_list = [1, 2, {1: 'a'}]
# copy_list = copy.deepcopy(my_list)
# copy_list.append(4)
# print(my_list)  # [1, 2, {1: 'a'}]
# print(copy_list)  # [1, 2, {1: 'a'}, 4]

# copy_list[2][2] = 'b'
# print(my_list)  # [1, 2, {1: 'a'}]

# # ++++++++++++++++++++++++++++++++++++++  Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Як ви вже зрозуміли, для класу Contacts створення поверхневої копії екземпляра класу не увінчається успіхом через те, 
# що ми маємо атрибут contacts, який є списком екземплярів об'єктів класу Person, а отже, 
# всі вони будуть передані за посиланням. Тому необхідно використовувати глибоке копіювання методом deepcopy з пакета copy

# Для класу Contacts реалізуйте функцію copy_class_contacts. 
# Як параметр вона приймає екземпляр класу Contacts і 
# повертає глибоку копію об'єкта за допомогою функції deepcopy з пакета copy.

# Приклад коду:

# persons = Contacts("user_class.dat", contacts)

# new_persons = copy_class_contacts(persons)

# new_persons.contacts[0].name = "Another name"

# print(persons.contacts[0].name)  # Allen Raymond
# print(new_persons.contacts[0].name)  # Another name

# +++++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Із нового тільки реалізація власної функції для глибокого копіювання класу . *copy_class_contacts(contacts)

# deepcopy(*якийсь_аргумент) - Робить повну копію і самого обєекта і його значень . Тобто відсутні будь які посилання на оригінал. 
#          Всі атрибути будути будуть перезаписані в інші комірки памняті . 
#         ніяких посилання на оригінал. Хоча всі значення будуть такимиж як в оригінала.


import copy
import pickle


class Person:
    def __init__(self, name: str, email: str, phone: str, favorite: bool):
        self.name = name
        self.email = email
        self.phone = phone
        self.favorite = favorite


def copy_class_person(person):
    return copy.copy(person)


class Contacts:
    def __init__(self, filename: str, contacts: list[Person] = None):
        if contacts is None:
            contacts = []
        self.filename = filename
        self.contacts = contacts
        self.is_unpacking = False
        self.count_save = 0

    def save_to_file(self):
        with open(self.filename, "wb") as file:
            pickle.dump(self, file)

    def read_from_file(self):
        with open(self.filename, "rb") as file:
            content = pickle.load(file)
        return content

    def __getstate__(self):
        attributes = self.__dict__.copy()
        attributes["count_save"] = attributes["count_save"] + 1
        return attributes

    def __setstate__(self, value):
        self.__dict__ = value
        self.is_unpacking = True


def copy_class_contacts(contacts):
    '''Власна функція як приймає один аргумент і повертає повну копію його з функції 
    Де нетільки сам обєкт буде повністю новий але й 
    всі його атрибути бутуть в окремих комірках памяті а не посиланням на оригінал'''
    
    deep_copy_class = copy.deepcopy(contacts) # застосовуємо вбудовану фінкуцію *deepcopy(*якийсь аргумент) пакету *copy
                                              # повну копію того що передано як аргумент

    return deep_copy_class # Повертаємо повну копію з фінкції.


# # # #  # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) +

contacts = [Person( "Allen Raymond", "nulla.ante@vestibul.co.uk", "(992) 914-3792", False,), 
             Person("Chaim Lewis","dui.in@egetlacus.ca", "(294) 840-6685", False,)]

persons = Contacts("user_class.dat", contacts)

new_persons = copy_class_contacts(persons)

new_persons.contacts[0].name = "Another name"

print(persons.contacts[0].name)  # Allen Raymond
print(new_persons.contacts[0].name)  # Another name