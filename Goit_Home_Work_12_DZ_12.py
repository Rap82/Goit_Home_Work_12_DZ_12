# ============================= Модуль 12 (останій в Python Core) =======================================

# +++++++++++++++++++++++++++++++++  Серіалізація об'єктів Python ++++++++++++++++++++++

#                             1.Серіалізація об'єктів Python
#                             2.Серіалізація об'єктів Python за допомогою pickle
#                             3.Серіалізація об'єктів Python за допомогою json
#                             4.Робота з таблицями CSV у Python
#                             5.Управління порядком серіалізації
#                             6.Створення копій об'єктів Python



# ================================ Звдання 1 / Task 1 ======================================

# ================================  2.Серіалізація об'єктів Python за допомогою pickle  ==========================

# Для серіалізації/десеріалізації об'єктів Python, коли важлива швидкість, коректність і невеликий розмір пам'яті, 
# що використовується, найкраще підійде пакет pickle.

# У пакета pickle є дві пари парних методів:

# Перша пара методів - це dumps, який упаковує в byte-рядок об'єкт, і loads - він розпаковує з byte-рядки в об'єкт.

# Ці методи потрібні, коли ми хочемо контролювати, що робити з byte поданням, наприклад, 
# відправити його по мережі або прийняти з мережі.

# import pickle

# some_data = {
#     (1, 3.5): 'tuple',
#     2: [1, 2, 3],
#     'a': {'key': 'value'}
# }

# byte_string = pickle.dumps(some_data)
# unpacked = pickle.loads(byte_string)

# print(unpacked == some_data)  # True
# print(unpacked is some_data)  # False
# У цьому прикладі упакований у byte_string словник some_data розпакован в unpacked та unpacked суворо дорівнює some_data, 
# але це все ж таки не той самий об'єкт.

# Друга пара методів: dump та load - вони упаковують у відкритий для byte-запису 
# файл і розпаковують з відкритого для byte-читання файлу.

# import pickle

# some_data = {
#     (1, 3.5): 'tuple',
#     2: [1, 2, 3],
#     'a': {'key': 'value'}
# }

# file_name = 'data.bin'

# with open(file_name, "wb") as fh:
#     pickle.dump(some_data, fh)

# with open(file_name, "rb") as fh:
#     unpacked = pickle.load(fh)

# print(unpacked == some_data)  # True
# print(unpacked is some_data)  # False
# Результат аналогічний попередньому прикладу. Головна відмінність у тому, 
# що під час виконання цього коду в робочій папці з'явився файл data.bin

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

#     {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів 
# за допомогою пакета pickle та зберігання отриманих даних у бінарному файлі.

# Перша функція write_contacts_to_file приймає два параметри: filename - ім'я файлу, contacts - список контактів. 
# Вона зберігає вказаний список у файл, використовуючи метод dump пакету pickle.

# Друга функція read_contacts_from_file читає та повертає зазначений список contacts з файлу filename, 
# використовуючи метод load пакету pickle.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Серіалізація і обернена до неї процедура Десіралізація схожа на роботу кодера - декодекр.
#            Спочатку - серіалізуємо дані , потім їх десерелізуємо за потреби. (По замовчуванню переводить в 
#             байт-рядки тому якщо треба працювати з серіалізованими даними то потрібно застосуовуати методи байт-рядків)(*для себе)


# import pickle # Імпортуємо пакет *pickle- Пакет Для серіалізації/десеріалізації об'єктів Python, 
#               # коли важлива швидкість, коректність і невеликий розмір пам'яті. 
#               # Просто перетворює всі дані в байт рядки і повертає за потреби з байт рядків дані назад . 
#               # також має методи запису і читання з файлу цих байт рядків.


# def write_contacts_to_file(filename, contacts):
#     ''' Функція приймає два аргумента , *filename - імя файлу в який будемо записувати наші контакти у вигляді байт-ряків
#     і contacts - самі дані які треба записати .
#     Відкриває наш файл для запису байт-рядків і за допомогою  метод *pickle.dump(contacts, fh) 
#     записуємо туди свої контакти у вигляді байт рядків'''
    
#     with open(filename, "wb") as fh: # Відкрити файл з іменем *filename(шлях до файлу тип Path) 
#                                      # для запису з параметром "wb" -байт-рядків, Задопомогою менеджера контексту *with ... as
#         pickle.dump(contacts, fh)    # Перетворюємо наші контакти в байт-рядки і передаємо їх файл-хендлеру *fh 
#                                      # за допомгою методу *pickle.dump(contacts, fh).
#                                      # По завершеню файл автоматично закриється і дані вньому збережуться.Читай менеджер контексту.
    

# def read_contacts_from_file(filename):
#     ''' Функція приймає один аргумента , *filename - імя файлу з якого будемо зчитувати наші контакти у вигляді байт-ряків
#     і повертати ї початковий вигляд.(той що був до сереалізації)
#     Відкриває наш файл для читання байт-рядків і за допомогою  метод *pickle.load(fh) 
#     Зчитуємо байт-дані і нормальний їх вигляд присвоюємо змінній contacts 
#     Повертаємо контакти з функції в їх початковому вигляді'''

#     with open(filename, "rb") as fh: # Відкрити файл з іменем *filename(шлях до файлу тип Path) 
#                                      # для читаннябайт-рядків з параметром "rb" - , Задопомогою менеджера контексту *with ... as
#         contacts = pickle.load(fh)   # Зчитуємо данні з файлового хендлера *fh і десерілізуємо їх за допомогою метода *pickle.load(fh)
#                                      # Присвоюємо десіралізовані дані зміній *contacts.
#     return contacts         # Повертаємо дані з функції



# # ================================ Звдання 2 / Task 2 ======================================

# # ================================  3.Серіалізація об'єктів Python за допомогою json  ==========================

# Протокол JSON (розшифровується як JavaScript Object Notation) дуже популярний в інтернеті протокол передачі. 
# Цей протокол має низку переваг:

# простий, його легко реалізувати;
# читабельний;
# відносно компактний (є набагато економніші протоколи).
# Перша перевага зробила JSON універсальним, будь-яка сучасна мова програмування підтримує JSON. 
# А якщо ні, то ви самі можете легко реалізувати підтримку JSON.

# Недоліки у JSON теж є:

# обмежений набір типів;
# ресурсомісткий (є і більш вимогливі до ресурсів протоколи).
# JSON підтримує такі типи даних:

# запис (як словник у Python), в якості ключа можуть бути тільки рядки, значення — будь-який JSON тип;
# масив (як список у Python);
# число (немає різниці між цілими чи дробовими);
# літерал (True, False, None);
# рядок.
# Як і у Python запис та масив можуть містити вкладені записи і/або словники будь-якої глибини вкладеності.

# Слід бути акуратним з конвертацією типів під час роботи з JSON у Python. 
# Кортежі під час розпакування з JSON стають списками, ключі словника, якщо вони були числами, стають рядками ж.

# Python підтримує JSON і в стандартному постачанні є пакет json, в якому є все необхідне для роботи з JSON.

# Методи dump та load зберігають дані у відкритий для запису файл і читають із відкритого для читання файлу.

# import json

# some_data = {'key': 'value', 2: [1, 2, 3], 'tuple': (5, 6), 'a': {'key': 'value'}}
# file_name = 'data.json'

# with open(file_name, "w") as fh:
#     json.dump(some_data, fh)

# with open(file_name, "r") as fh:
#     unpacked = json.load(fh)

# unpacked is some_data  # False
# unpacked == some_data  # False

# unpacked['key'] == some_data['key']  # True
# unpacked['a'] == some_data['a']  # True
# unpacked['2'] == some_data[2]  # True
# unpacked['tuple'] == [5, 6]  # True
# Результатом буде файл data.json із наступною структурою.

# {
#   "key": "value",
#   "2": [
#     1,
#     2,
#     3
#   ],
#   "tuple": [
#     5,
#     6
#   ],
#   "a": {
#     "key": "value"
#   }
# }

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

# {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів за допомогою пакету json 
# та зберігання отриманих даних у текстовому файлі.

# Перша функція write_contacts_to_file приймає два параметри: filename - ім'я файлу, contacts - список контактів. 
# Вона зберігає вказаний список у файл, використовуючи метод dump пакету json.

# Структура json файлу має бути такою:

# {
#   "contacts": [
#     {
#       "name": "Allen Raymond",
#       "email": "nulla.ante@vestibul.co.uk",
#       "phone": "(992) 914-3792",
#       "favorite": false
#     },
#     ...
#   ]
# }
# Тобто список контактів повинен зберігатися за ключем "contacts", а не просто зберегти список у файл.

# Друга функція read_contacts_from_file читає та повертає зазначений список contacts з файлу filename, 
# збереженого раніше функцією write_contacts_to_file, використовуючи метод load пакету json.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : завдання схоже на попереднє тільки тут використовуємо бібілотеку json 
#           і її методи серіалізації *json.dump і *json.load , які для запису і зчитування 
#           використовую звичайні типи дани,х а не байт рядки як попередня бібліотека *pickle 
            # Також є додаткова умова в завданні що дані мають бути записані в словник з ключем "contacts" що 
            # й і реалізуємо в коді. Щось додатково коментувати в цьому завдані потреби не бачу.

# import json

# def write_contacts_to_file(filename, contacts):
#     with open(filename, "w") as fh:
#         json_dict = {"contacts" : contacts}
#         json.dump(json_dict, fh)

# def read_contacts_from_file(filename):
#     with open(filename, "r") as fh:
#         json_dict = json.load(fh)
#         return json_dict["contacts"]



# # ================================ Звдання 3 / Task 3 ======================================

# # ================================  4.Робота з таблицями CSV у Python  ==========================

# Ще один формат обміну інформацією, що дуже часто використовується — це табличне уявлення. 
# Відкритий формат для зберігання табличних даних, який підтримується будь-яким редактором — це формат csv.
# Формат csv є, по суті, тим самим текстовим файлом, 
# але з умовою, що вся інформація в ньому розділена на колонки та рядки символами роздільниками. 
# Типово колонки поділяють комою, а рядки — символ нового рядка. Але можна використати будь-яку іншу комбінацію символів.

# Python підтримує роботу з табличними даними у форматі csv. Для цього у стандартному постачанні йде пакет csv.

# import csv

# with open('eggs.csv', 'w', newline='') as fh:
#     spam_writer = csv.writer(fh)
#     spam_writer.writerow(['Spam'] * 5 + ['Baked Beans'])
#     spam_writer.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])

# with open('eggs.csv', newline='') as fh:
#     spam_reader = csv.reader(fh)
#     for row in spam_reader:
#         print(', '.join(row))
# В результаті виконання цього коду в робочій папці з'явився файл eggs.csv. 
# Якщо відкриєте його табличним редактором, він відкриється як таблиця.

# Є два допоміжні класи в пакеті csv, які виконують роботу з табличними даними трохи зручніше:

# import csv

# with open('names.csv', 'w', newline='') as fh:
#     field_names = ['first_name', 'last_name']
#     writer = csv.DictWriter(fh, fieldnames=field_names)
#     writer.writeheader()
#     writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
#     writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
#     writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})

# with open('names.csv', newline='') as fh:
#     reader = csv.DictReader(fh)
#     for row in reader:
#         print(row['first_name'], row['last_name'])
# Класи DictWriter та DictReader дозволяють працювати з рядками таблиці як зі словниками, 
# де як ключі використовуються назви колонок (перший рядок).

# Таким чином за допомогою Python можна генерувати табличні дані та імпортувати дані з таблиць.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

#     {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів за допомогою пакету csv та 
# зберігання отриманих даних у текстовому файлі.

# Перша функція write_contacts_to_file приймає два параметри: 
# filename - ім'я файлу, contacts - список контактів. Вона зберігає вказаний список у файлі формату csv.

# Структура csv файлу має бути такою:

# name,email,phone,favorite
# Allen Raymond,nulla.ante@vestibul.co.uk,(992) 914-3792,False
# Chaim Lewis,dui.in@egetlacus.ca,(294) 840-6685,False
# Kennedy Lane,mattis.Cras@nonenimMauris.net,(542) 451-7038,True
# Wylie Pope,est@utquamvel.net,(692) 802-2949,False
# Cyrus Jackson,nibh@semsempererat.com,(501) 472-5218,True
# Зверніть увагу, першим рядком у файлі йдуть заголовки – це назви ключів.

# Друга функція read_contacts_from_file читає, 
# виконує перетворення даних та повертає вказаний список contacts із файлу filename, 
# збереженого раніше функцією write_contacts_to_file.

# Примітка: При читанні файлу csv ми отримуємо властивість словника favorite у вигляді рядка, тобто. 
# наприклад favorite='False' . 
# Необхідно його привести до логічного виразу назад, щоб стало favorite=False.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++
# *Примітка :# Ще один формат обміну інформацією, що дуже часто використовується — це табличне уявлення. 
             # Відкритий формат для зберігання табличних даних, який підтримується будь-яким редактором — це формат csv.
             # Формат csv є, по суті, тим самим текстовим файлом, 
             # але з умовою, що вся інформація в ньому розділена на колонки та рядки символами роздільниками. 
             # Типово колонки поділяють комою, а рядки — символ нового рядка. Але можна використати будь-яку іншу комбінацію символів.
             # Python підтримує роботу з табличними даними у форматі csv. Для цього у стандартному постачанні йде пакет csv

import csv # Імпортуємо вбудований пакет *csv в Python



def write_contacts_to_file(filename, contacts):
    '''Власна функція для конвертації і запису даних в csv-форматі з файлу з розширенням *.csv. 
    де дані є  список з елементами - словники.
    Тобто дані передані з списку *contacts пертворює в csv-формат і записує в файл з іменем що мітиться в *filename
    Запис в файл відбувається з параметром 'w'. Отже файл потрібного формату має бути створений на диску , 
    і він буде постійно перезаписуватись наново при кжному виклику функції *write_contacts_to_file(filename, contacts)
    Приймає два аргумента: 
      *filename - імя файлу з розширенням *.csv в який буде записувати дані .
      *contacts - дані які будемо записувати в файл, 
            В нашому випадку список, де кожен елемент словник встановленого формату(дивись умову задачі)
            '''

    with open(filename, 'w', newline='') as fh: # відкриваємо файл  з  іменем з *filename для запису з парметром *'w', 
                                                # і додатковим параметром *newline=''- цей параметер вказує на те що запис в файл буде робитись рядок за рядком, 
                                                # якщо параметр *newline='' - невказаний, запис у файл відбувається через пустий рядок.(дані, пустий_рядок,дані, пустий_рядок) 

        field_names = ["name", "email", "phone", "favorite"] # Формуємо перше поле для запису в форматі *.csv , Це має бути - header(шапка) 
                                    # Тут перечисляємо ключі словника щоб утворити загаловок таблиці .
                                    # Важливо щоб ці ключі були такі як і ключі в словниках які будуть передаватись для формування таблиці.
                                    # Інакше кажучи Дані які будемо записувати в *.csv-форматі Бажано щоб були однакового формату. 
                                    # Тобто містили такі ж ключі, і таку ж їх кількість як у заголовку таблиці .
                                    # В нашому випадку в списку *field_names. Детальніше читай в інтернеті щоб буде якщо дані не будуть порібного формату.    
        

        writer = csv.DictWriter(fh, fieldnames=field_names) # Створюємо екзепляр класу *<class 'csv.DictWriter'> з іменем *writer , 
                                                            # за допомогою вбудованого модуля класу *DictWriter(fh, fieldnames=field_names) пакету *csv.
                                                            # де fh - файловий хендлер , і fieldnames= - список ключів(заголовків таблиці),
                                                            # Які ще аргументи і які поля та методи має клас *DictWriter читай в інтренеті.
# Примітка : оскільки ми імпортували весь пакет *csv то виклик потрібного нам модуля *DictWriter  відбувається через крапку. *csv.DictWriter 
            # Шаблон виклику (*імя_пакету.*імя_його_модуля)
                                                            
        #print(type(writer)) # *<class 'csv.DictWriter'> # тестовий принт(для себе ) щоб переконатись що екзепляр потрібного класу.
        
        writer.writeheader() # Метод *.writeheader() - класу 'csv.DictWriter' , 
                             # Записує перший рядок в csv-файл, Заголовки-ключі таблиці , Тобто те що містить аргумент *fieldnames 
        writer.writerows(contacts) # Метод *.writerows(*якісь_ітерабельні_днані) , 
                                   # Проводить запис відразу всіх переданих даних у csv -файл-таблицю. Де кожен елемент запишеться з нового рядка.
                                   # В нашому випадку *contacts - це список з елементами якого є словники відповідного формату.
                                   # Тому ми використовуємо клас *DictWriter- клас для запису словників в csv-(файл-таблицю).
# Таблиця буде мати наступний вигляд : 
        # Перший рядок завжди (рядок заголовків-ключів): name,email,phone,favorite
        # Наступні рядки - Значення відповідних ключів з переданих словників отримані за ключами з заголовку.
       
        # name,email,phone,favorite 
        # Allen Raymond,nulla.ante@vestibul.co.uk,(992) 914-3792,False
        # Chaim Lewis,dui.in@egetlacus.ca,(294) 840-6685,False     
                                    
        

def read_contacts_from_file(filename):
    '''Функція для читання і конвертації даних в csv-форматі з файлу з розширенням *.csv. 
    в список з елементами - словники. 
    Фактично виконує обернену дію до  *write_contacts_to_file(filename, contacts)
    Приймає один аргумент, імя_файлу що містять конвертовані дані *csv-формат (дані csv-формат типу словники)
    Для зчитування будемо використовувати клас *DictReader пакету *csv - клас конвертації даних з *csv-формату в словники  
    Конвертовані словники будемо добавляти в список , список елементи якого є словники повертаємо з функції.
*Примітка : під час конвертації даних в сsv формат всі дані стають рядками(тип *str) , коли конвертуємо назад дані то вони повернуться як рядки (тип *str).
    Тому ті дані які мають мати інший тип, потрібно переприсвоїти через функцію  *eval(*str)
    *eval(*str) - конвертує дані з *str в початковий тип. Якщо коверт не можливий повертає помилку  '''

    with open(filename,'r', newline='') as fh: # Відкримаємо наш файл з іменм що міститься в *filename , для читання - параметр "r"
                                               # і параметром newline='' (*вказано що потрібно цей пераметр щоб коректно зчитувати дані з файла *.csv, хоча для зчитування він мабуть необовязковий.) 
        reader = csv.DictReader(fh) # Створюємо ітерабельний екзепляр класу <class 'csv.DictReader'> з іменем *reader
                                    # атрибути якого будуть містити конвертовані дані з csv-файла.(підсказка -словники)
        #print(type(reader))  # Тестовий прітнт Дляконтрою значеннь
        list_contacts = [] # Список в який будемо додавати наші елементи (конвертовані з csv-файла словники)
        
        for row in reader: # оскільки наш екзепляр *reader класу <class 'csv.DictReader'> ітерабельний(створюється таким позамочуванню)
                           # То ми можемо пройтись по ньому циклом. на кожній ітерації циклу буде повертати словник 
                           # cформований з ключами із заголовків і відповідними їх значеннями з таблиці *csv-файлу
                           # Приклад : {'name':'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': 'False'}
            
            row["favorite"] = eval(row["favorite"]) # Повертаємо кючу "favorite" його початкове значення за допомогою вбудованої функції *eval(*str)(читай опис вищеабо в інтрнеті)
                                                    # Було 'favorite': "False"(значення тип *str)-  стане 'favorite': False (значення тип *bool)
            list_contacts.append(row) # На кожній ітерації циклу добавляємо наш приведений до початковго стану словник в спиок контактів *list_contacts
    return list_contacts # Повертаємо сформований список контактів де кожний елемент буде словником вказаного формату з функції.

 # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++              

filename = "csv_file.csv" # Створений файл з розширенням *.csv для тестових вправ. Файл створюємо в папці де мітиться код в якому плануємо його використовувати, інакше потрібно вказувати шлях до  файлу.
contacts =  [{'name':'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': False},
             {'name': 'Chaim Lewis', 'email': 'dui.in@egetlacus.ca', 'phone': '(294) 840-6685', 'favorite': True}]

write_contacts_to_file(filename , contacts) # Викликаємо функцію *write_contacts_to_file і передаємо її потрібні аргументи.
                                            # вміст файлу csv_file.csv  переглядаємо за допомогою блокнота чи екселя або інших файлофих редакторів які можуть читати цей формат.
                                            # Примітка : Якщо відкрити цей файл в vs_code .буде видно тільки запис *data
print (read_contacts_from_file(filename))  # Принтимо результат . Перевіряємо чи він співпадає з ти що в *contacts ,Все відпрацювало як треба , автоперевіка прийняла результат.

# [{'name': 'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': False}, 
# {'name': 'Chaim Lewis', 'email': 'dui.in@egetlacus.ca', 'phone': '(294) 840-6685', 'favorite': True}]