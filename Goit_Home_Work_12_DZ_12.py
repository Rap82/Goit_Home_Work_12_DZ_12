# ============================= Модуль 12 (останій в Python Core) =======================================

# +++++++++++++++++++++++++++++++++  Серіалізація об'єктів Python ++++++++++++++++++++++

#                             1.Серіалізація об'єктів Python
#                             2.Серіалізація об'єктів Python за допомогою pickle
#                             3.Серіалізація об'єктів Python за допомогою json
#                             4.Робота з таблицями CSV у Python
#                             5.Управління порядком серіалізації
#                             6.Створення копій об'єктів Python



# ================================ Звдання 1 / Task 1 ======================================

# ================================  2.Серіалізація об'єктів Python за допомогою pickle  ==========================

# Для серіалізації/десеріалізації об'єктів Python, коли важлива швидкість, коректність і невеликий розмір пам'яті, 
# що використовується, найкраще підійде пакет pickle.

# У пакета pickle є дві пари парних методів:

# Перша пара методів - це dumps, який упаковує в byte-рядок об'єкт, і loads - він розпаковує з byte-рядки в об'єкт.

# Ці методи потрібні, коли ми хочемо контролювати, що робити з byte поданням, наприклад, 
# відправити його по мережі або прийняти з мережі.

# import pickle

# some_data = {
#     (1, 3.5): 'tuple',
#     2: [1, 2, 3],
#     'a': {'key': 'value'}
# }

# byte_string = pickle.dumps(some_data)
# unpacked = pickle.loads(byte_string)

# print(unpacked == some_data)  # True
# print(unpacked is some_data)  # False
# У цьому прикладі упакований у byte_string словник some_data розпакован в unpacked та unpacked суворо дорівнює some_data, 
# але це все ж таки не той самий об'єкт.

# Друга пара методів: dump та load - вони упаковують у відкритий для byte-запису 
# файл і розпаковують з відкритого для byte-читання файлу.

# import pickle

# some_data = {
#     (1, 3.5): 'tuple',
#     2: [1, 2, 3],
#     'a': {'key': 'value'}
# }

# file_name = 'data.bin'

# with open(file_name, "wb") as fh:
#     pickle.dump(some_data, fh)

# with open(file_name, "rb") as fh:
#     unpacked = pickle.load(fh)

# print(unpacked == some_data)  # True
# print(unpacked is some_data)  # False
# Результат аналогічний попередньому прикладу. Головна відмінність у тому, 
# що під час виконання цього коду в робочій папці з'явився файл data.bin

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

#     {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів 
# за допомогою пакета pickle та зберігання отриманих даних у бінарному файлі.

# Перша функція write_contacts_to_file приймає два параметри: filename - ім'я файлу, contacts - список контактів. 
# Вона зберігає вказаний список у файл, використовуючи метод dump пакету pickle.

# Друга функція read_contacts_from_file читає та повертає зазначений список contacts з файлу filename, 
# використовуючи метод load пакету pickle.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Серіалізація і обернена до неї процедура Десіралізація схожа на роботу кодера - декодекр.
#            Спочатку - серіалізуємо дані , потім їх десерелізуємо за потреби. (По замовчуванню переводить в 
#             байт-рядки тому якщо треба працювати з серіалізованими даними то потрібно застосуовуати методи байт-рядків)(*для себе)


# import pickle # Імпортуємо пакет *pickle- Пакет Для серіалізації/десеріалізації об'єктів Python, 
#               # коли важлива швидкість, коректність і невеликий розмір пам'яті. 
#               # Просто перетворює всі дані в байт рядки і повертає за потреби з байт рядків дані назад . 
#               # також має методи запису і читання з файлу цих байт рядків.


# def write_contacts_to_file(filename, contacts):
#     ''' Функція приймає два аргумента , *filename - імя файлу в який будемо записувати наші контакти у вигляді байт-ряків
#     і contacts - самі дані які треба записати .
#     Відкриває наш файл для запису байт-рядків і за допомогою  метод *pickle.dump(contacts, fh) 
#     записуємо туди свої контакти у вигляді байт рядків'''
    
#     with open(filename, "wb") as fh: # Відкрити файл з іменем *filename(шлях до файлу тип Path) 
#                                      # для запису з параметром "wb" -байт-рядків, Задопомогою менеджера контексту *with ... as
#         pickle.dump(contacts, fh)    # Перетворюємо наші контакти в байт-рядки і передаємо їх файл-хендлеру *fh 
#                                      # за допомгою методу *pickle.dump(contacts, fh).
#                                      # По завершеню файл автоматично закриється і дані вньому збережуться.Читай менеджер контексту.
    

# def read_contacts_from_file(filename):
#     ''' Функція приймає один аргумента , *filename - імя файлу з якого будемо зчитувати наші контакти у вигляді байт-ряків
#     і повертати ї початковий вигляд.(той що був до сереалізації)
#     Відкриває наш файл для читання байт-рядків і за допомогою  метод *pickle.load(fh) 
#     Зчитуємо байт-дані і нормальний їх вигляд присвоюємо змінній contacts 
#     Повертаємо контакти з функції в їх початковому вигляді'''

#     with open(filename, "rb") as fh: # Відкрити файл з іменем *filename(шлях до файлу тип Path) 
#                                      # для читаннябайт-рядків з параметром "rb" - , Задопомогою менеджера контексту *with ... as
#         contacts = pickle.load(fh)   # Зчитуємо данні з файлового хендлера *fh і десерілізуємо їх за допомогою метода *pickle.load(fh)
#                                      # Присвоюємо десіралізовані дані зміній *contacts.
#     return contacts         # Повертаємо дані з функції



# # ================================ Звдання 2 / Task 2 ======================================

# # ================================  3.Серіалізація об'єктів Python за допомогою json  ==========================

# Протокол JSON (розшифровується як JavaScript Object Notation) дуже популярний в інтернеті протокол передачі. 
# Цей протокол має низку переваг:

# простий, його легко реалізувати;
# читабельний;
# відносно компактний (є набагато економніші протоколи).
# Перша перевага зробила JSON універсальним, будь-яка сучасна мова програмування підтримує JSON. 
# А якщо ні, то ви самі можете легко реалізувати підтримку JSON.

# Недоліки у JSON теж є:

# обмежений набір типів;
# ресурсомісткий (є і більш вимогливі до ресурсів протоколи).
# JSON підтримує такі типи даних:

# запис (як словник у Python), в якості ключа можуть бути тільки рядки, значення — будь-який JSON тип;
# масив (як список у Python);
# число (немає різниці між цілими чи дробовими);
# літерал (True, False, None);
# рядок.
# Як і у Python запис та масив можуть містити вкладені записи і/або словники будь-якої глибини вкладеності.

# Слід бути акуратним з конвертацією типів під час роботи з JSON у Python. 
# Кортежі під час розпакування з JSON стають списками, ключі словника, якщо вони були числами, стають рядками ж.

# Python підтримує JSON і в стандартному постачанні є пакет json, в якому є все необхідне для роботи з JSON.

# Методи dump та load зберігають дані у відкритий для запису файл і читають із відкритого для читання файлу.

# import json

# some_data = {'key': 'value', 2: [1, 2, 3], 'tuple': (5, 6), 'a': {'key': 'value'}}
# file_name = 'data.json'

# with open(file_name, "w") as fh:
#     json.dump(some_data, fh)

# with open(file_name, "r") as fh:
#     unpacked = json.load(fh)

# unpacked is some_data  # False
# unpacked == some_data  # False

# unpacked['key'] == some_data['key']  # True
# unpacked['a'] == some_data['a']  # True
# unpacked['2'] == some_data[2]  # True
# unpacked['tuple'] == [5, 6]  # True
# Результатом буде файл data.json із наступною структурою.

# {
#   "key": "value",
#   "2": [
#     1,
#     2,
#     3
#   ],
#   "tuple": [
#     5,
#     6
#   ],
#   "a": {
#     "key": "value"
#   }
# }

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

# {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів за допомогою пакету json 
# та зберігання отриманих даних у текстовому файлі.

# Перша функція write_contacts_to_file приймає два параметри: filename - ім'я файлу, contacts - список контактів. 
# Вона зберігає вказаний список у файл, використовуючи метод dump пакету json.

# Структура json файлу має бути такою:

# {
#   "contacts": [
#     {
#       "name": "Allen Raymond",
#       "email": "nulla.ante@vestibul.co.uk",
#       "phone": "(992) 914-3792",
#       "favorite": false
#     },
#     ...
#   ]
# }
# Тобто список контактів повинен зберігатися за ключем "contacts", а не просто зберегти список у файл.

# Друга функція read_contacts_from_file читає та повертає зазначений список contacts з файлу filename, 
# збереженого раніше функцією write_contacts_to_file, використовуючи метод load пакету json.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : завдання схоже на попереднє тільки тут використовуємо бібілотеку json 
#           і її методи серіалізації *json.dump і *json.load , які для запису і зчитування 
#           використовую звичайні типи дани,х а не байт рядки як попередня бібліотека *pickle 
            # Також є додаткова умова в завданні що дані мають бути записані в словник з ключем "contacts" що 
            # й і реалізуємо в коді. Щось додатково коментувати в цьому завдані потреби не бачу.

# import json

# def write_contacts_to_file(filename, contacts):
#     with open(filename, "w") as fh:
#         json_dict = {"contacts" : contacts}
#         json.dump(json_dict, fh)

# def read_contacts_from_file(filename):
#     with open(filename, "r") as fh:
#         json_dict = json.load(fh)
#         return json_dict["contacts"]



# # ================================ Звдання 3 / Task 3 ======================================

# # ================================  4.Робота з таблицями CSV у Python  ==========================

# Ще один формат обміну інформацією, що дуже часто використовується — це табличне уявлення. 
# Відкритий формат для зберігання табличних даних, який підтримується будь-яким редактором — це формат csv.
# Формат csv є, по суті, тим самим текстовим файлом, 
# але з умовою, що вся інформація в ньому розділена на колонки та рядки символами роздільниками. 
# Типово колонки поділяють комою, а рядки — символ нового рядка. Але можна використати будь-яку іншу комбінацію символів.

# Python підтримує роботу з табличними даними у форматі csv. Для цього у стандартному постачанні йде пакет csv.

# import csv

# with open('eggs.csv', 'w', newline='') as fh:
#     spam_writer = csv.writer(fh)
#     spam_writer.writerow(['Spam'] * 5 + ['Baked Beans'])
#     spam_writer.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])

# with open('eggs.csv', newline='') as fh:
#     spam_reader = csv.reader(fh)
#     for row in spam_reader:
#         print(', '.join(row))
# В результаті виконання цього коду в робочій папці з'явився файл eggs.csv. 
# Якщо відкриєте його табличним редактором, він відкриється як таблиця.

# Є два допоміжні класи в пакеті csv, які виконують роботу з табличними даними трохи зручніше:

# import csv

# with open('names.csv', 'w', newline='') as fh:
#     field_names = ['first_name', 'last_name']
#     writer = csv.DictWriter(fh, fieldnames=field_names)
#     writer.writeheader()
#     writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
#     writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
#     writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})

# with open('names.csv', newline='') as fh:
#     reader = csv.DictReader(fh)
#     for row in reader:
#         print(row['first_name'], row['last_name'])
# Класи DictWriter та DictReader дозволяють працювати з рядками таблиці як зі словниками, 
# де як ключі використовуються назви колонок (перший рядок).

# Таким чином за допомогою Python можна генерувати табличні дані та імпортувати дані з таблиць.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список, кожен елемент якого є словником з контактами користувача наступного виду:

#     {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача name, його email, телефонний номер phone та властивість favorite - обраний контакт чи ні.

# Розробіть дві функції для серіалізації та десеріалізації списку контактів за допомогою пакету csv та 
# зберігання отриманих даних у текстовому файлі.

# Перша функція write_contacts_to_file приймає два параметри: 
# filename - ім'я файлу, contacts - список контактів. Вона зберігає вказаний список у файлі формату csv.

# Структура csv файлу має бути такою:

# name,email,phone,favorite
# Allen Raymond,nulla.ante@vestibul.co.uk,(992) 914-3792,False
# Chaim Lewis,dui.in@egetlacus.ca,(294) 840-6685,False
# Kennedy Lane,mattis.Cras@nonenimMauris.net,(542) 451-7038,True
# Wylie Pope,est@utquamvel.net,(692) 802-2949,False
# Cyrus Jackson,nibh@semsempererat.com,(501) 472-5218,True
# Зверніть увагу, першим рядком у файлі йдуть заголовки – це назви ключів.

# Друга функція read_contacts_from_file читає, 
# виконує перетворення даних та повертає вказаний список contacts із файлу filename, 
# збереженого раніше функцією write_contacts_to_file.

# Примітка: При читанні файлу csv ми отримуємо властивість словника favorite у вигляді рядка, тобто. 
# наприклад favorite='False' . 
# Необхідно його привести до логічного виразу назад, щоб стало favorite=False.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# *Примітка :# Ще один формат обміну інформацією, що дуже часто використовується — це табличне уявлення. 
             # Відкритий формат для зберігання табличних даних, який підтримується будь-яким редактором — це формат csv.
             # Формат csv є, по суті, тим самим текстовим файлом, 
             # але з умовою, що вся інформація в ньому розділена на колонки та рядки символами роздільниками. 
             # Типово колонки поділяють комою, а рядки — символ нового рядка. Але можна використати будь-яку іншу комбінацію символів.
             # Python підтримує роботу з табличними даними у форматі csv. Для цього у стандартному постачанні йде пакет csv

# import csv # Імпортуємо вбудований пакет *csv в Python



# def write_contacts_to_file(filename, contacts):
#     '''Власна функція для конвертації і запису даних в csv-форматі з файлу з розширенням *.csv. 
#     де дані є  список з елементами - словники.
#     Тобто дані передані з списку *contacts пертворює в csv-формат і записує в файл з іменем що мітиться в *filename
#     Запис в файл відбувається з параметром 'w'. Отже файл потрібного формату має бути створений на диску , 
#     і він буде постійно перезаписуватись наново при кжному виклику функції *write_contacts_to_file(filename, contacts)
#     Приймає два аргумента: 
#       *filename - імя файлу з розширенням *.csv в який буде записувати дані .
#       *contacts - дані які будемо записувати в файл, 
#             В нашому випадку список, де кожен елемент словник встановленого формату(дивись умову задачі)
#             '''

#     with open(filename, 'w', newline='') as fh: # відкриваємо файл  з  іменем з *filename для запису з парметром *'w', 
#                                                 # і додатковим параметром *newline=''- цей параметер вказує на те що запис в файл буде робитись рядок за рядком, 
#                                                 # якщо параметр *newline='' - невказаний, запис у файл відбувається через пустий рядок.(дані, пустий_рядок,дані, пустий_рядок) 

#         field_names = ["name", "email", "phone", "favorite"] # Формуємо перше поле для запису в форматі *.csv , Це має бути - header(шапка) 
#                                     # Тут перечисляємо ключі словника щоб утворити загаловок таблиці .
#                                     # Важливо щоб ці ключі були такі як і ключі в словниках які будуть передаватись для формування таблиці.
#                                     # Інакше кажучи Дані які будемо записувати в *.csv-форматі Бажано щоб були однакового формату. 
#                                     # Тобто містили такі ж ключі, і таку ж їх кількість як у заголовку таблиці .
#                                     # В нашому випадку в списку *field_names. Детальніше читай в інтернеті щоб буде якщо дані не будуть порібного формату.    
        

#         writer = csv.DictWriter(fh, fieldnames=field_names) # Створюємо екзепляр класу *<class 'csv.DictWriter'> з іменем *writer , 
#                                                             # за допомогою вбудованого модуля класу *DictWriter(fh, fieldnames=field_names) пакету *csv.
#                                                             # де fh - файловий хендлер , і fieldnames= - список ключів(заголовків таблиці),
#                                                             # Які ще аргументи і які поля та методи має клас *DictWriter читай в інтренеті.
# # Примітка : оскільки ми імпортували весь пакет *csv то виклик потрібного нам модуля *DictWriter  відбувається через крапку. *csv.DictWriter 
#             # Шаблон виклику (*імя_пакету.*імя_його_модуля)
                                                            
#         #print(type(writer)) # *<class 'csv.DictWriter'> # тестовий принт(для себе ) щоб переконатись що екзепляр потрібного класу.
        
#         writer.writeheader() # Метод *.writeheader() - класу 'csv.DictWriter' , 
#                              # Записує перший рядок в csv-файл, Заголовки-ключі таблиці , Тобто те що містить аргумент *fieldnames 
#         writer.writerows(contacts) # Метод *.writerows(*якісь_ітерабельні_днані) , 
#                                    # Проводить запис відразу всіх переданих даних у csv -файл-таблицю. Де кожен елемент запишеться з нового рядка.
#                                    # В нашому випадку *contacts - це список з елементами якого є словники відповідного формату.
#                                    # Тому ми використовуємо клас *DictWriter- клас для запису словників в csv-(файл-таблицю).
# # Таблиця буде мати наступний вигляд : 
#         # Перший рядок завжди (рядок заголовків-ключів): name,email,phone,favorite
#         # Наступні рядки - Значення відповідних ключів з переданих словників отримані за ключами з заголовку.
       
#         # name,email,phone,favorite 
#         # Allen Raymond,nulla.ante@vestibul.co.uk,(992) 914-3792,False
#         # Chaim Lewis,dui.in@egetlacus.ca,(294) 840-6685,False     
                                    
        

# def read_contacts_from_file(filename):
#     '''Функція для читання і конвертації даних в csv-форматі з файлу з розширенням *.csv. 
#     в список з елементами - словники. 
#     Фактично виконує обернену дію до  *write_contacts_to_file(filename, contacts)
#     Приймає один аргумент, імя_файлу що містять конвертовані дані *csv-формат (дані csv-формат типу словники)
#     Для зчитування будемо використовувати клас *DictReader пакету *csv - клас конвертації даних з *csv-формату в словники  
#     Конвертовані словники будемо добавляти в список , список елементи якого є словники повертаємо з функції.
# *Примітка : під час конвертації даних в сsv формат всі дані стають рядками(тип *str) , коли конвертуємо назад дані то вони повернуться як рядки (тип *str).
#     Тому ті дані які мають мати інший тип, потрібно переприсвоїти через функцію  *eval(*str)
#     *eval(*str) - конвертує дані з *str в початковий тип. Якщо коверт не можливий повертає помилку  '''

#     with open(filename,'r', newline='') as fh: # Відкримаємо наш файл з іменм що міститься в *filename , для читання - параметр "r"
#                                                # і параметром newline='' (*вказано що потрібно цей пераметр щоб коректно зчитувати дані з файла *.csv, хоча для зчитування він мабуть необовязковий.) 
#         reader = csv.DictReader(fh) # Створюємо ітерабельний екзепляр класу <class 'csv.DictReader'> з іменем *reader
#                                     # атрибути якого будуть містити конвертовані дані з csv-файла.(підсказка -словники)
#         #print(type(reader))  # Тестовий прітнт Дляконтрою значеннь
#         list_contacts = [] # Список в який будемо додавати наші елементи (конвертовані з csv-файла словники)
        
#         for row in reader: # оскільки наш екзепляр *reader класу <class 'csv.DictReader'> ітерабельний(створюється таким позамочуванню)
#                            # То ми можемо пройтись по ньому циклом. на кожній ітерації циклу буде повертати словник 
#                            # cформований з ключами із заголовків і відповідними їх значеннями з таблиці *csv-файлу
#                            # Приклад : {'name':'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': 'False'}
            
#             row["favorite"] = eval(row["favorite"]) # Повертаємо кючу "favorite" його початкове значення за допомогою вбудованої функції *eval(*str)(читай опис вищеабо в інтрнеті)
#                                                     # Було 'favorite': "False"(значення тип *str)-  стане 'favorite': False (значення тип *bool)
#             list_contacts.append(row) # На кожній ітерації циклу добавляємо наш приведений до початковго стану словник в спиок контактів *list_contacts
#     return list_contacts # Повертаємо сформований список контактів де кожний елемент буде словником вказаного формату з функції.

#  # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++              

# filename = "csv_file.csv" # Створений файл з розширенням *.csv для тестових вправ. Файл створюємо в папці де мітиться код в якому плануємо його використовувати, інакше потрібно вказувати шлях до  файлу.
# contacts =  [{'name':'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': False},
#              {'name': 'Chaim Lewis', 'email': 'dui.in@egetlacus.ca', 'phone': '(294) 840-6685', 'favorite': True}]

# write_contacts_to_file(filename , contacts) # Викликаємо функцію *write_contacts_to_file і передаємо її потрібні аргументи.
#                                             # вміст файлу csv_file.csv  переглядаємо за допомогою блокнота чи екселя або інших файлофих редакторів які можуть читати цей формат.
#                                             # Примітка : Якщо відкрити цей файл в vs_code .буде видно тільки запис *data
# print (read_contacts_from_file(filename))  # Принтимо результат . Перевіряємо чи він співпадає з ти що в *contacts ,Все відпрацювало як треба , автоперевіка прийняла результат.

# # [{'name': 'Allen Raymond', 'email': 'nulla.ante@vestibul.co.uk,', 'phone': '(992) 914-3792', 'favorite': False}, 
# # {'name': 'Chaim Lewis', 'email': 'dui.in@egetlacus.ca', 'phone': '(294) 840-6685', 'favorite': True}]

# # ================================ Звдання 4 / Task 4 ======================================

# # ================================  2.Серіалізація об'єктів Python за допомогою pickle  ==========================

# Ви можете зберігати об'єкти для подальшого використання, але за умови, 
# щоб pickle міг коректно зберегти, а потім розпакувати упакований об'єкт класу, 
# необхідно, щоб сам клас був оголошений раніше у коді, де відбувається розпакування.

# import pickle


# class Human:
#     def __init__(self, name):
#         self.name = name


# bob = Human("Bob")
# encoded_bob = pickle.dumps(bob)

# decoded_bob = pickle.loads(encoded_bob)

# bob.name == decoded_bob.name  # True
# Але якби ви захотіли передати об'єкт bob по мережі іншому комп'ютеру, 
# який нічого не знає про клас Human, то ви отримаєте помилку.
# Якщо ж на обох кінцях каналу зв'язку оголошено клас Human, то такий обмін працюватиме.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Приклад створення екземпляра класу:

#     Person(
#     "Allen Raymond",
#     "nulla.ante@vestibul.co.uk",
#     "(992) 914-3792",
#     False,
# )
# Розробіть клас Contacts. Він повинен ініціалізувати через конструктор дві властивості: 
# filename - ім'я файлу для пакування об'єкта класу Contacts, contacts - список контактів, екземплярів класу Person.

# Приклад створення екземпляра класу:

# contacts = [
#     Person(
#         "Allen Raymond",
#         "nulla.ante@vestibul.co.uk",
#         "(992) 914-3792",
#         False,
#     ),
#     Person(
#         "Chaim Lewis",
#         "dui.in@egetlacus.ca",
#         "(294) 840-6685",
#         False,
#     ),
# ]

# persons = Contacts("user_class.dat", contacts)
# Розробіть два методи для серіалізації та десеріалізації екземпляра класу Contacts за допомогою пакету pickle 
# та зберігання даних у бінарному файлі.

# Перший метод save_to_file зберігає екземпляр класу Contacts у файл, використовуючи метод dump пакету pickle. 
# Ім'я файлу зберігається в атрибуті filename.

# Другий метод read_from_file читає та повертає екземпляр класу Contacts з файлу filename, 
# використовуючи метод load пакету pickle.

# Приклад роботи:

# persons = Contacts("user_class.dat", contacts)
# persons.save_to_file()
# person_from_file = persons.read_from_file()
# print(persons == person_from_file)  # False
# print(persons.contacts[0] == person_from_file.contacts[0])  # False
# print(persons.contacts[0].name == person_from_file.contacts[0].name)  # True
# print(persons.contacts[0].email == person_from_file.contacts[0].email)  # True
# print(persons.contacts[0].phone == person_from_file.contacts[0].phone)  # True

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

import pickle # Модуль pickle реалізує двійкові протоколи для серіалізації та десеріалізації структури об’єктів Python. 
              # «Pickling» - це процес, за допомогою якого ієрархія об’єктів Python перетворюється на потік байтів, 
              # а «unpickling» - це зворотна операція, за допомогою якої потік байтів (з binary file або bytes-like object) перетворюється назад в ієрархію об’єктів. Травлення (і розбирання) також відоме як «серіалізація», «маршалінг», [1] або «зведення»; однак, щоб уникнути плутанини, тут використовуються терміни «маринування» та «розмаринування».


class Person:
    '''Клас -даних.
    Має свій конструктор в якому реалізовано 4 обовязкові поля:
    *name, *email, *phone, *favorite
    Клас для зберігання даних про особу.
        '''
    def __init__(self, name: str, email: str, phone: str, favorite: bool):
        self.name  = name
        self.email = email
        self.phone = phone
        self.favorite = favorite


  
class Contacts:
    '''Клас контактів - Виконує серіалізацію і зберігання даних у файл, а також вивантаження та десеріалізацію даних з нього, 
     Має свій конструктор в якому реалізовано 2 обовязкові поля: 
     *filename - імя файлу в який будемо зберігати і вигружати з нього дані про особу.
     *contacts - список елементи якого будуть екзепляри класу *Person  
    Також має два власних методи:
    *save_to_file(self) -   Виконує серіалізацію і зберігання даних у файл
    *read_from_file(self) - Виконує вивантаження та десеріалізацію даних з файлу  '''
    def __init__(self, filename: str, contacts: list[Person] = None):
        
        if contacts is None: # Перевіряємо чи передались дані в аргумент *contacts, якщо ні- *contacts буде містити занчення позамовчуванню *None
            contacts = []    # Якщо умова виконалась, значить аргумент *contacts непередався, отже встановлюємо *contacts = []  
        #print(type(contacts)) # Тестовий принт для контрою значення (для себе)
        self.contacts = contacts
        self.filename = filename

    def save_to_file(self):
        '''Метод без аргументів - 
        Виконує серіалізацію за допомогою вбудованого методу *pickle.dump(*обєкт/екзепляр, *файловий_хендлер) пакету *pickle 
        і зберігання даних у файл '''
        
        #print(type(self.contacts)) # Тестовий принт для контрою значення (для себе)
        with open(self.filename, "wb") as fh:  # Відкриваємо файл для запису в байт-рядки *"wb" ,за допомогою менеджера контексту *with ...as
            pickle.dump(self, fh)  # Виконуємо серіалізацію за допомогою вбудованого методу *pickle.dump(*обєкт/екзепляр, *файловий_хендлер) пакету *pickle
                                   # Де *self(посилання на самого себе ) - екзепляр класу *Contacts , *fh- файловий хендлер.
    def read_from_file(self):
        '''Метод без аргументів - 
        Виконує вивантаження даних з файлу і десеріалізацію за допомогою вбудованого методу *pickle.load(*файловий_хендлер) пакету *pickle 
        '''
        with open(self.filename, "rb") as fh: # Відкриваємо файл для зчитування в байт-рядків *"rb" , за допомогою менеджера контексту *with ...as

            result = pickle.load(fh) # Виконуємо десеріалізацію за допомогою вбудованого методу *pickle.load(*файловий_хендлер) пакету *pickle
                                     # Десеріалзовані дані присвоюємо змінній *result(буде мітити початкові дані які були до серіалізовані) 
        
        return result # Обєкт класу *Contacts вигляду *<__main__.Contacts object at 0x000001C60FD5BD40>
        
        


#  # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++
        
filename = "My_class_contacts.dat" # Створений файл з розширенням *.dat для тестових вправ. Файл створюємо в папці де мітиться код в якому плануємо його використовувати, інакше потрібно вказувати шлях до  файлу.

# persons = Person("Allen Raymond","nulla.ante@vestibul.co.uk","(992) 914-3792", False)

contacts = [Person( "Allen Raymond", "nulla.ante@vestibul.co.uk", "(992) 914-3792", False,), 
            Person("Chaim Lewis","dui.in@egetlacus.ca", "(294) 840-6685", False,)]

persons = Contacts("My_class_contacts.dat", contacts) # Створюємо екзепляр класу *Contacts з іменем *persons 
persons.save_to_file() # Перевіряємо у файлі чи відбувся запис даних, в VS_Code можна глянути відразу
person_from_file = persons.read_from_file() # Присвоюємо *person_from_file екзепляр класу *Contacts десеріалізований з файлу "My_class_contacts.dat".
                                            # *person_from_file - це буде новий екзепляр класу *Contacts про те всі поля будуть містити індентичнч дані що й і оріганал.
print (person_from_file)  # <__main__.Contacts object at 0x000002585BABBD40>
print(persons == person_from_file)  # False  # Порівнюємо орігінальний екзепляр з його клонм після десеріалізації. Буде False бо це різні обєекти.
print(persons.contacts[0] == person_from_file.contacts[0])  # False . # Буде False бо в кожного екзепляра свої посилання на однакові поля.
print(persons.contacts[0].name == person_from_file.contacts[0].name)    # True # Буде True бо значення будуть одинакові
print(persons.contacts[0].email == person_from_file.contacts[0].email)  # True # Буде True бо значення будуть одинакові
print(persons.contacts[0].phone == person_from_file.contacts[0].phone)  # True # Буде True бо значення будуть одинакові